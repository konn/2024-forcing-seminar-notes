@require: class-jlreq/theorem
@require: math
@require: enumitem/enumitem
@require: azmath/azmath
@require: bibyfi/bibyfi
@require: bibyfi/bibyfi-IEEETran
@require: pervasives
@require: fss/fss
@require: ruby/ruby
@require: base/list-ext
@require: latexcmds/latexcmds
@require: matrix/matrix
@require: arrows/arrows
@require: arrows/commands

let-math \lrarrow = ${\longleftrightarrow}
let-math \CH = ${\mathrm{CH}}
let-math \ZF = ${\mathrm{ZF}}
let-math \NK = ${\mathrm{NK}}
let-math \HK = ${\mathrm{HK}}
let-math \LK = ${\mathrm{LK}}
let-math \CL = ${\mathrm{CL}}
let-math \MP = ${\mathrm{MP}}
let-math \mcomma = ${\mrquad!(3.0 /. 18.0)}
let-math \Gen = ${\mathrm{Gen}}
let-math \FinSeq arg = ${\mathord{\text!{}^{<\omega} #arg}}
let-math \seq arity arg = ${\mathord{\text!{}^{#arity} #arg}}
let-math \Pow = ${\mathop{\mathcal{P}}}
let-math \implies = ${\Longrightarrow}
let-math \iff = ${\Longleftrightarrow}
let-math \overset m-over m =
  text-in-math MathOrd (fun ctx -> (
    let font-size = ctx |> get-font-size in
    let ib-over = embed-math (ctx |> set-font-size (font-size *' 0.85)) m-over in
    let ib-over = inline-fil ++ ib-over ++ inline-fil in
    let ib-m = embed-math ctx m in
    let ib-sp = inline-graphics 0pt (font-size *' 0.1) 0pt (fun _ -> []) in
    line-stack-bottom [ib-over; ib-sp; ib-m]
  ))

let iff-arrow = Arrow.of-bth (|
  body = ArrowBody.(
    solid (|width = 0.05;|)
    |> shift 0.2
  );
  head = ArrowHead.(vee (|
    line-width = 0.05;
    size = 0.15;
    ext = 0.1;
  |));
  tail = ArrowTail.(vee (|
    line-width = 0.05;
    size = 0.15;
    ext = -0.5;
  |));
|)
let-math \defs = ${\mathrel{\overset{\text!{def}}{\Longleftrightarrow}}}
let-math \K = ${𝖪}
let-math \S = ${𝖲}
let-math \P = ${𝖯}
let-math \G = ${𝖦}
let-math \F = ${𝖥}
let-math \J = ${𝖩}
let-math \lh = ${\mathop{\mathrm{lh}}}
let mid-space-ratio = 0.1875
let-math \Set a b = ${\set-builder{\mrquad!(mid-space-ratio)#a\mrquad!(mid-space-ratio)}{\mrquad!(mid-space-ratio)#b\mrquad!(mid-space-ratio)}}
let minus l = 0pt -' l
let gr-abs-bracket-m thk vlen fsize color =

  % 基準となる横の位置 (h) 及び 縦の位置 (v) の座標．
  let hmin = minus fsize *' 0.2 in
  let h0 = 0pt in
  let hmax = fsize *' 0.2 in
  let va = vlen in

  % 結ぶことになる点の座標．
  let (x0, y0) = (0pt, va) in
  let (x1, y1) = (0pt, minus va) in

  let path =
    start-path (x0, y0)
      |> line-to (x1, y1)
      |> terminate-path
  in
  let xmin = hmin in
  let xmax = hmax in
  (
    [stroke thk color path],
    (xmin, minus vlen), (xmax, vlen),
    (fun _ -> 0pt)
  )
let-math \Seq m m-cond =
  open AZMathParens in
  let lparen = paren-scheme (gr-angle-bracket 0.5pt true) half-height-default in
  let mparen = paren-scheme (gr-abs-bracket-m 0.5pt) half-height-default in
  let rparen = paren-scheme (gr-angle-bracket 0.5pt false) half-height-default in
  math-paren-with-middle lparen rparen mparen [${\mrquad!(mid-space-ratio)#m\mrquad!(mid-space-ratio)};  ${\mrquad!(mid-space-ratio)#m-cond\mrquad!(mid-space-ratio)}]
let-inline \emph arg = {\font-style[bold](arg);}
let-inline \gruby arg1 arg2 = {\ruby?:[Ruby.mode Ruby.g](arg1)(arg2);}
let-mutable defn-counter <- 0
let-block ctx +defn = JLReqTheorem.theorem-scheme(JLReqTheorem.default-config-theorem){定義} defn-counter ctx
let-mutable example-counter <- 0
let-block ctx +example = JLReqTheorem.theorem-scheme(JLReqTheorem.default-config-theorem){例} example-counter ctx
let-mutable theorem-counter <- 0
let-block ctx +theorem = JLReqTheorem.theorem-scheme(JLReqTheorem.default-config-theorem){定理} theorem-counter ctx
open LatexCmds

let math-font-scale sty sz m = text-in-math sty 
  (fun ctx -> 
      read-inline (ctx |> set-font-size (get-font-size ctx *' sz)) {${#m}}
  )
let-math \mathsize sty sz m = math-font-scale sty sz m

let-math \subst a subss =
  let froms = List.map (fun (x, y) -> x) subss
  in let tos = List.map (fun (x,y) -> y) subss
  in ${\mathord{#a\pB{\mathsize!(MathOrd)!(0.75){\matrix-body![froms; tos]}}}}
