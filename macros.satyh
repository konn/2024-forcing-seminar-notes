@require: class-jlreq/theorem
@require: math
@require: enumitem/enumitem
@require: azmath/azmath
@require: azmath/accent
@require: bibyfi/bibyfi
@require: bibyfi/bibyfi-IEEETran
@require: pervasives
@require: ruby/ruby
@require: base/list-ext
@require: latexcmds/latexcmds
@require: matrix/matrix
@require: arrows/arrows
@require: arrows/commands
@require: colorbox/colorbox
@require: fss/fss
@require: uline/uline
@import: colors

let output-cross-reference ctx l =
  let ref-txt = 
    match (get-cross-reference l) with
    | None -> {?}
    | Some(s) -> embed-string s
  in let body = text-in-math MathOrd (fun ctx -> read-inline ctx ref-txt)
  in let m = ${(#body)}
  in embed-math ctx m
let-inline ctx \eqref l = 
  output-cross-reference ctx (`eq:` ^ l ^ `:num`)
let-math \lrarrow = ${\longleftrightarrow}
let-math \CH = ${\mathrm{CH}}
let-math \dot arg = ${\adot{#arg}}
let-math \ZF = ${\mathrm{ZF}}
let-math \Z = ${\mathrm{Z}}
let-math \ZFC = ${\mathrm{ZFC}}
let-math \BPI = ${\mathrm{BPI}}
let-math \ulcorner = math-char MathOpen `‚åú`
let-math \urcorner = math-char MathClose `‚åù`
let-math \code arg = ${\ulcorner #arg \urcorner}
let-math \Sk = ${\mathop{\mathrm{Sk}}}
let-math \Con = ${\mathop{\mathrm{Con}}}
let-math \Cl = ${\mathop{\mathrm{Cl}}}
let-math \AC = ${\mathrm{AC}}
let-math \NK = ${\mathrm{NK}}
let-math \HK = ${\mathrm{HK}}
let-math \LK = ${\mathrm{LK}}
let-math \CL = ${\mathrm{CL}}
let-math \defeq = ${\coloneq}
let-math \MP = ${\mathrm{MP}}
let-math \Fml = ${\mathrm{Fml}}
let-math \Sent = ${\mathrm{Sent}}
let-math \mphantom a =
  text-in-math MathOrd (fun ctx -> (
    let ib-a = embed-math ctx a in
    let (wid, ht, dp) = get-natural-metrics ib-a in
    let ib-phantom = inline-graphics wid ht dp (fun _ -> []) in
    line-stack-bottom [ib-phantom]
  ))
let-math \On = ${\mathrm{On}}
let-math \models = ${\vDash}
let-math \nmodels = ${\nvDash}
let-math \forces = ${\Vdash}
let-math \nforces = ${\nVdash}
let-math \nforces = ${\nVdash}
let-math \liff = ${\longleftrightarrow}
let-math \muline arg = ${\text!{\uline{${#arg}}}}
let-math \Cd = ${\mathrm{Cd}}
let-math \diamondsuit = ${‚ô¢}
let-math \CC = ${\mathrm{CC}}
let-math \HF = ${\mathrm{HF}}
let-math \DC = ${\mathrm{DC}}
let-math \AD = ${\mathrm{AD}}
let-math \null = ${\mathord{ùóáùóéùóÖùóÖ}}
let-math \PFA = ${\mathrm{PFA}}
let-math \cf a = ${\mathop{\mathrm{cf}} #a}
let-math \mcomma = ${\mrquad!(3.0 /. 18.0)}
let-math \Gen = ${\mathrm{Gen}}
let-math \FinSeq arg = ${\mathord{\text!{}^{<\omega} #arg}}
let-math \seq arity arg = ${\mathord{\text!{}^{#arity} #arg}}
let-math \Pow = ${\mathop{\mathcal{P}}}
let-math \implies = ${\Longrightarrow}
let-math \iff = ${\Longleftrightarrow}
let-math \overset m-over m =
  text-in-math MathOrd (fun ctx -> (
    let font-size = ctx |> get-font-size in
    let ib-over = embed-math (ctx |> set-font-size (font-size *' 0.85)) m-over in
    let ib-over = inline-fil ++ ib-over ++ inline-fil in
    let ib-m = embed-math ctx m in
    let ib-sp = inline-graphics 0pt (font-size *' 0.1) 0pt (fun _ -> []) in
    line-stack-bottom [ib-over; ib-sp; ib-m]
  ))

let iff-arrow = Arrow.of-bth (|
  body = ArrowBody.(
    solid (|width = 0.05;|)
    |> shift 0.2
  );
  head = ArrowHead.(vee (|
    line-width = 0.05;
    size = 0.15;
    ext = 0.1;
  |));
  tail = ArrowTail.(vee (|
    line-width = 0.05;
    size = 0.15;
    ext = -0.5;
  |));
|)
let-math \defs = ${\mathrel{\overset{\text!{def}}{\Longleftrightarrow}}}
let-math \reals = ${\seq{\omega}{2}}
let-math \K = ${ùñ™}
let-math \S = ${ùñ≤}
let-math \A = ${ùñ†}
let-math \P = ${ùñØ}
let-math \G = ${ùñ¶}
let-math \F = ${ùñ•}
let-math \J = ${ùñ©}
let-math \lh = ${\mathop{\mathrm{lh}}}
let mid-space-ratio = 0.1875
let-math \Set a b = ${\set-builder{\mrquad!(mid-space-ratio)#a\mrquad!(mid-space-ratio)}{\mrquad!(mid-space-ratio)#b\mrquad!(mid-space-ratio)}}
let minus l = 0pt -' l
let gr-abs-bracket-m thk vlen fsize color =

  % Âü∫Ê∫ñ„Å®„Å™„ÇãÊ®™„ÅÆ‰ΩçÁΩÆ (h) Âèä„Å≥ Á∏¶„ÅÆ‰ΩçÁΩÆ (v) „ÅÆÂ∫ßÊ®ôÔºé
  let hmin = minus fsize *' 0.2 in
  let h0 = 0pt in
  let hmax = fsize *' 0.2 in
  let va = vlen in

  % Áµê„Å∂„Åì„Å®„Å´„Å™„ÇãÁÇπ„ÅÆÂ∫ßÊ®ôÔºé
  let (x0, y0) = (0pt, va) in
  let (x1, y1) = (0pt, minus va) in

  let path =
    start-path (x0, y0)
      |> line-to (x1, y1)
      |> terminate-path
  in
  let xmin = hmin in
  let xmax = hmax in
  (
    [stroke thk color path],
    (xmin, minus vlen), (xmax, vlen),
    (fun _ -> 0pt)
  )

let-math \Seq m m-cond =
  open AZMathParens in
  let lparen = paren-scheme (gr-angle-bracket 0.5pt true) half-height-default in
  let mparen = paren-scheme (gr-abs-bracket-m 0.5pt) half-height-default in
  let rparen = paren-scheme (gr-angle-bracket 0.5pt false) half-height-default in
  math-paren-with-middle lparen rparen mparen [${\mrquad!(mid-space-ratio)#m\mrquad!(mid-space-ratio)};  ${\mrquad!(mid-space-ratio)#m-cond\mrquad!(mid-space-ratio)}]

let define-theorem ?:config name ?:rule-color counter ctx ?:label ?:title body =
  let () = counter <- !counter + 1
  in let num = arabic !counter 
  in let rule-color = Option.from (Color.gray 0.5) rule-color
  in let () = Option.map-or () (fun label -> register-cross-reference (label ^ `:num`) (name ^ num)) label
  in let name = embed-string name
  in let number = embed-string num
  in let read-heading i = read-inline ctx {\font-style[bold]{#i;}}
  in let suffix = Option.map-or (read-heading {}) (fun title -> inline-skip (get-font-size ctx *' 0.5) ++ read-heading {(#title;)}) title
  in let zw = JLReqLib.get-length ctx ~(jlreq-length @`1zw`)
  in let heading = read-heading name ++ read-heading number ++ suffix ++ read-heading {.} ++ inline-skip zw
  in let () = JLReqParagraph.set-paragraph-top-text heading
  in open Colorbox
  in let style =
        [ title-filled false
        ; sharrp-corners-all
        ; toprule 0pt
        ; bottomrule 0pt
        ; rightrule 0pt
        ; leftrule 5pt
        ; left-skip 5pt
        ; left (zw *' 1.5)
        ; top zw
        ; bottom zw
        ; colback Color.white
        ; colframe rule-color
        ]
  in read-block ctx '< +colorbox(style)(body); >

let define-theorem-nonumber ?:config name ?:rule-color  ctx ?:label ?:title body =
    let rule-color = Option.from (Color.gray 0.5) rule-color
    in let name = embed-string name
    in let read-heading i = read-inline ctx {\font-style[bold]{#i;}}
    in let suffix = Option.map-or (read-heading {}) (fun title -> inline-skip (get-font-size ctx *' 0.5) ++ read-heading {(#title;)}) title
    in let zw = JLReqLib.get-length ctx ~(jlreq-length @`1zw`)
    in let heading = read-heading name ++ suffix ++ read-heading {.} ++ inline-skip zw
    in let () = JLReqParagraph.set-paragraph-top-text heading
    in open Colorbox
    in let style =
          [ title-filled false
          ; sharrp-corners-all
          ; toprule 0pt
          ; bottomrule 0pt
          ; rightrule 0pt
          ; leftrule 5pt
          ; left-skip 5pt
          ; left (zw *' 1.5)
          ; top zw
          ; bottom zw
          ; colback Color.white
          ; colframe rule-color
          ]
    in read-block ctx '< +colorbox(style)(body); >
    

let-math \aleph = ${‚Ñµ}
let-math \proves = ${\vdash}
let-math \nproves = ${\nvdash}
let-math \deffml = ${\mathrel{:\equiv}}
let-math \FV = ${\mathop{\mathrm{FV}}}
let-inline \eqn-notag x = {\eqn?:(AZMathEquation.notag)(x);}
let-block +eqn-notag x = '<+eqn?:(AZMathEquation.notag)(x);>
let prop-color = Colors.gray 0.25
let conj-color = Colors.gray 0.75
let example-color = Color.rgb .25 .25 .75
let exer-color = Color.rgb .0 .75 .9
let remark-color = Color.rgb 1. 0.75 0.0
let defn-color = Color.rgb .25 .6 .25
let-inline \emph arg = {\font-style[bold](arg);}
let-inline \gruby arg1 arg2 = {\ruby?:[Ruby.mode Ruby.g](arg1)(arg2);}
let-mutable defn-counter <- 0
let-block ctx +defn = define-theorem `ÂÆöÁæ©` ?:defn-color defn-counter ctx
let-mutable example-counter <- 0
let-block ctx +example = define-theorem `‰æã` ?:example-color example-counter ctx
let-mutable theorem-counter <- 0
let-block ctx +theorem = define-theorem `ÂÆöÁêÜ` ?:prop-color theorem-counter ctx
let-mutable remark-counter <- 0
let-block ctx +remark = define-theorem `Ê≥®ÊÑè` ?:remark-color remark-counter ctx
let-mutable lemma-counter <- 0
let-block ctx +lemma = define-theorem `Ë£úÈ°å` ?:prop-color theorem-counter ctx
let-block ctx +cor = define-theorem `Á≥ª` ?:prop-color theorem-counter ctx
let-mutable conjecture-counter <- 0
let-block ctx +conjecture = define-theorem `‰∫àÊÉ≥` ?:conj-color conjecture-counter ctx
let-mutable exercise-counter <- 0
let-block ctx +exercise = define-theorem `ÊºîÁøí` ?:exer-color exercise-counter ctx
let-block ctx +notation = define-theorem-nonumber `Ë®òÊ≥ï` ?:defn-color ctx
let-math \GCH  = ${\mathord{\mathrm{GCH}}}
open LatexCmds

let math-font-scale sty sz m = text-in-math sty 
  (fun ctx -> 
      read-inline (ctx |> set-font-size (get-font-size ctx *' sz)) {${#m}}
  )
let-math \mathsize sty sz m = math-font-scale sty sz m

let-math \subst a subss =
  let froms = List.map (fun (x, y) -> x) subss
  in let tos = List.map (fun (x,y) -> y) subss
  in ${\mathord{#a\pB{\mathsize!(MathOrd)!(0.75){\matrix-body![froms; tos]}}}}

let add-pt (x1, y1) (x2, y2) = (x1 +' x2, y1 +' y2)
let scale-pt (x1, y1) r = (x1 *' r, y1 *' r)
let sub-pt (x1, y1) (x2, y2) = (x1 -' x2, y1 -' y2)

let extend-spline p0 p1 p2 p3 =
  let v0 = add-pt (scale-pt (sub-pt p2 p0) (1.0 /. 6.0)) p1 in
  let v1 = add-pt (scale-pt (sub-pt p1 p3) (1.0 /. 6.0)) p2 in
  bezier-to v0 v1 p2

let-rec draw-splines
  | width col [] = [] 
  | width col (start :: pts ) =
  open Gr in
  let-rec go 
        | p0 p1 p2 (p3 :: ps) acc = 
            extend-spline p0 p1 p2 p3 acc
              |> go p1 p2 p3 ps
        | p0 p1 p2 [] acc = 
            extend-spline p0 p1 p2 (add-pt p2 (scale-pt (sub-pt p2 p1) 0.25)) acc
  in match pts with
  | [] -> []
  | (tgt :: []) -> [stroke width col (line start tgt)]
  | (p1 :: p2 :: ps) ->
      [stroke 
        width col
        ( terminate-path
          (go (add-pt start (scale-pt (sub-pt start p1) 0.25)) 
              start p1 (p2 :: ps) (start-path start))
        )
      ]

let minus l = 0pt -' l
let reflect-x = linear-transform-path (0.0 -. 1.0) 0.0 0.0 1.0

let pads-double-sqbracket is-open fsize =
  let (pad-inner, pad-outer) = (fsize *' 0.02, fsize *' 0.12) in
  if is-open
  then (pad-outer, pad-inner, 0pt)
  else (pad-inner, pad-outer, 0pt)

let gr-double-sqbracket thk is-open vlen fsize color =
    % Âü∫Ê∫ñ„Å®„Å™„ÇãÊ®™„ÅÆ‰ΩçÁΩÆ (h) Âèä„Å≥ Á∏¶„ÅÆ‰ΩçÁΩÆ (v) „ÅÆÂ∫ßÊ®ôÔºé
    let hmin = minus fsize *' 0.12 in
    let h0 = 0pt in
    let ha = vlen *' 0.14 +' fsize *' 0.2 in
    let hmax = ha +' fsize *' 0.02 in
    let va = vlen in

    % Áµê„Å∂„Åì„Å®„Å´„Å™„ÇãÁÇπ„ÅÆÂ∫ßÊ®ôÔºé
    let (x0, y0) = (ha, va) in
    let (x01, y01) = (ha *' 0.4, va) in
    let (x1, y1) = (0pt, va) in
    let (x2, y2) = (0pt, minus va) in
    let (x23, y23) = (ha *' 0.4, minus va) in
    let (x3, y3) = (ha, minus va) in

    let path-outer =
      start-path (x0, y0)
        |> line-to (x1, y1)
        |> line-to (x2, y2)
        |> line-to (x3, y3)
        |> terminate-path
    in
    let path-vert = start-path (x01, y01) |> line-to (x23, y23) |> terminate-path in
    let path = unite-path path-outer path-vert in
    let path = if is-open then path else reflect-x path in
    let xmin = if is-open then hmin else minus hmax in
    let xmax = if is-open then hmax else minus hmin in
    (
      [stroke thk color path],
      (xmin, minus vlen), (xmax, vlen),
      (fun _ -> 0pt)
    )

let max-len l1 l2 = if l1 >' l2 then l1 else l2

let double-sqbracket-l =  
      AZMathParens.paren-scheme 
        (gr-double-sqbracket 0.5pt true) 
        AZMathParens.half-height-default
let double-sqbracket-r = 
  AZMathParens.paren-scheme 
      (gr-double-sqbracket 0.5pt false) 
      AZMathParens.half-height-default
let accent-scheme str-acc wid-acc-r acc-thickness-r shift-offset-opt inner =
  let embedf ctx =
    let accent = math-char MathOrd str-acc in
    let ib-inner = embed-math ctx inner in
    let ib-accent = embed-math ctx accent in
    let (wid-in, ht-in, dp-in) = get-natural-metrics ib-inner in
    let (_, ht-acc, _) = get-natural-metrics ib-accent in

    let offset-acc = ht-acc -' (ctx |> get-font-size) *' acc-thickness-r in
    let wid-acc = (ctx |> get-font-size) *' wid-acc-r in
    let shift-offset = (ctx |> get-font-size) *' (shift-offset-opt |> Option.from 0.) in
    let ht = max-len ht-in ht-acc in
    let dp = dp-in in

    let xoffset =
      if wid-in >' wid-acc
      then % Âè≥ÊèÉ„Åà
        wid-in
      else % ‰∏≠Â§ÆÊèÉ„Åà
        wid-in +' (wid-acc -' wid-in) *' 0.5
    in

    let grlst (x, y) =
      [
        draw-text (x, y) ib-inner;
        draw-text (x +' xoffset +' shift-offset, y +' ht-in -' offset-acc) ib-accent;
      ]
    in

    math-graphics MathOrd wid-in ht dp grlst
  in

  math-in-math MathOrd embedf
    
    
let-math \check ?:shift inner = 
  open Gr in open Color in
  let shift = Option.from 0pt shift in
  math-in-math MathOrd 
      (fun ctx -> (
        let ib-inner = embed-math ctx inner in
        let (wid-in, ht-in, dp-in) = get-natural-metrics ib-inner in
        let check-hpad = wid-in *' 0.2 in
        let check-ht = wid-in *' 0.2 in
        let check-vpad = ht-in *' 1.25 in
        math-graphics MathOrd wid-in ht-in dp-in 
          (fun (x, y) -> 
            [ draw-text (x, y) ib-inner
            ; stroke 0.5pt black 
              ( start-path (shift +' x +' check-hpad, y +' check-vpad +' check-ht)
                |> line-to (shift +' x +' wid-in *' 0.5, y +' check-vpad)
                |> line-to (shift +' x +' wid-in -' check-hpad, y +' check-vpad +' check-ht)
                |> terminate-path
              )
            ]
          )
        )
      )

let-math \pSQ ?:ht m =
  let half-height = match ht with
  | Some(ht) -> AZMathParens.half-height-fixed ht 
  | None -> AZMathParens.half-height-default
  in math-paren
      (AZMathParens.paren-scheme (gr-double-sqbracket 0.5pt true) half-height)
      (AZMathParens.paren-scheme (gr-double-sqbracket 0.5pt false) half-height)
      m

let-math \lt = ${<}
let-math \gt = ${>}
let-math \compat = ${\mathrel{‚à•}}
let-math \restrict = ${\mathbin{\upharpoonright}}
let gr-slash-m thk vlen fsize color =

  % Âü∫Ê∫ñ„Å®„Å™„ÇãÊ®™„ÅÆ‰ΩçÁΩÆ (h) Âèä„Å≥ Á∏¶„ÅÆ‰ΩçÁΩÆ (v) „ÅÆÂ∫ßÊ®ôÔºé
  let hmin = minus fsize *' 0.2 in
  let h0 = 0pt in
  let hmax = fsize *' 0.2 in
  let va = vlen in

  % Áµê„Å∂„Åì„Å®„Å´„Å™„ÇãÁÇπ„ÅÆÂ∫ßÊ®ôÔºé
  let (x0, y0) = (5pt, va) in
  let (x1, y1) = (-5pt, minus va) in

  let path =
    start-path (x0, y0)
      |> line-to (x1, y1)
      |> terminate-path
  in
  let xmin = hmin in
  let xmax = hmax in
  (
    [ draw-text (0pt, 0pt) (read-inline (get-initial-context 2pt (command \math) |> set-text-color Colors.white) {${/}})
    ; stroke thk color path],
    (xmin, minus vlen), (xmax, vlen),
    (fun _ -> 0pt)
  )
let-math \quot over under =
  open AZMathParens in
  let over = math-transform (raise-inline 2.5pt) MathOrd over in
  let under = math-transform (raise-inline -2.5pt) MathOrd under in
  let lparen = empty-bracket-l in
  let mparen = paren-scheme (gr-slash-m 0.75pt) half-height-default in
  let rparen = empty-bracket-r in
  math-paren-with-middle lparen rparen mparen [${\mrquad!(mid-space-ratio)#over\mrquad!(mid-space-ratio)};  ${\mrquad!(mid-space-ratio)#under\mrquad!(mid-space-ratio)}]

let-math \ultpow index m u =
  ${\quot {\seq{#index}{#m}}{#u}}
