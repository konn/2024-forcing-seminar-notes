@require: class-jlreq/jlreq
@require: class-jlreq/theorem
@require: math
@require: enumitem/enumitem
@require: azmath/azmath
@require: bibyfi/bibyfi
@require: bibyfi/bibyfi-IEEETran
@require: pervasives
@require: fss/fss
@require: ruby/ruby
@require: figbox/figbox
@require: base/list-ext
@require: latexcmds/latexcmds
@require: matrix/matrix
@require: arrows/arrows
@require: arrows/commands
@require: gr
@require: arrows/arrows
@require: color
@require: derive/derive
@import: macros
@import: references
@import: presets

let-math \E = ${𝖤}
let-math \bold-in = 
  text-in-math MathRel 
    (fun ctx -> 
      ( let sz = get-font-size ctx in
        let cl = get-text-color ctx in
        let (w,h,d) = get-natural-metrics (read-inline ctx {${\in}}) in
        let newh = h -' d *' 0.5 in
        let thick = 1pt in
        let neww = w *' 0.75 in
        inline-graphics w h d
            (fun (x, y) ->
              [ draw-text (x, y) (read-inline (ctx |> set-text-color Colors.white) {${\in}})
              ; stroke thick cl
                (Gr.line (x, y +' newh *' .5) (x +' neww, y +' newh *' .5))
              ; stroke thick cl
                  (start-path (x +' neww, y +' newh)
                  |> line-to (x +' neww *' .5, y +' newh)
                  |> bezier-to
                      (x, y +' newh)
                      (x, y +' newh *' .75)
                      (x, y +' newh *' .5)
                  |> bezier-to
                      (x, y +' newh *' .25)
                      (x, y)
                      (x +' neww *' .5, y)
                  |> line-to (x +' neww, y)
                  |> terminate-path)
              ]
            )
      )
    )
in
let-math \bold-plus = 
  text-in-math MathBin
    (fun ctx -> 
      ( let sz = get-font-size ctx in
        let cl = get-text-color ctx in
        let (w,h,d) = get-natural-metrics (read-inline ctx {${+}}) in
        let newh = h -' d *' .5 in
        let thick = 1.25pt in
        let neww = w in
        inline-graphics w h d
            (fun (x, y) ->
              [ draw-text (x, y) (read-inline (ctx |> set-text-color Colors.white) {${+}})
              ; stroke thick cl
                (Gr.line (x, y +' h *' .5) (x +' neww, y +' h *' .5))
              ; stroke thick cl
                (Gr.line (x +' w *' .5, y -' d) (x +' neww *' .5, y +' h))
              ]
            )
      )
    )
in
let-math \bold-dot = 
  text-in-math MathBin
    (fun ctx -> 
      ( let sz = get-font-size ctx in
        let cl = get-text-color ctx in
        let (w,h,d) = get-natural-metrics (read-inline ctx {${\cdot}}) in
        let newh = h in
        let neww = w in
        inline-graphics w h d
            (fun (x, y) ->
              [ draw-text (x, y) (read-inline (ctx |> set-text-color Colors.white) {${\cdot}})
              ; fill cl
                (Gr.circle (x +' neww *' .5, y +' newh *' .5) 1.5pt)
              ]
            )
      )
    )
in

document (|
  title = {\no-break{強制法セミナー第1回：数理論理学の初歩}};
  author = {Hiromi ISHII (\@mr_konn)};
  date = {2024-06-23};
|)'<
  +section?:(`chap:syntax`){一階述語論理の構文と証明体系}<

    +p{
      \emph{一階述語論理}は、予め固定された言語の下で、与えられた集合の元の間の関係を使って記述できるような性質を扱う論理体系である。現代数学は、一階述語論理の下で適切な強さの公理系の集合論\footnote{ここでの「集合論」は${\ZF}に限らない広い意味でのものである。よく、圏論が「集合論に代わる数学の基礎として採用できる」と説明されることがあるが、これはつよつよ圏であるトポスの内部言語を使うことで集合論を代替できる、という話で、${\ZF}とは違う集合論の「実装」を与えることができる、という話である。}を採用すれば全て展開できることが知られている。
    }

    +p{
      ${\ZF}集合論は一階述語論理で記述される理論であり、集合論では一階述語論理に関する数理論理学の結果を縦横無尽に使う。本稿ではその必要最小限の事実を振り返っておく。
      まずは、一階述語論理の構文と意味論について簡単に見ていこう。一階述語論理では議論したい理論ごとに言語${\mathcal{L}}を固定して議論をする。一階述語論理における言語とは、何が項で何が論理式なのかを確定させるのに必要な記号の集まりである。
    }

    +p{
      本節のより踏み込んだ内容については、証明論寄りの内容は古森・小野\cite[`古森・小野:2010`];や戸次\cite[`戸次:2012`];を参考にされたい。
    }

    +defn?:(`formula`)?:({一階述語論理の項と論理式})<
      +p{
        一階述語論理の言語${\mathcal{L}}は次の構成要素から成る：
        \listing{
          * 関数記号${\bm{f}^{(n_0)}_0, \bm{f}^{(n_1)}_1, \bm{f}^{(n_2)}_2, \ldots \mhquad (n_i \in ℕ)}
          * 関係記号${\bm{R}^{(m_0)}_0, \bm{R}^{(m_1)}_1, \bm{R}^{(m_2)}_2, \ldots \mhquad (m_i \in ℕ) }
        }
        上添え字の${(n_i), (m_i)}は記号の一部ではなく、各記号ごとに割り当てられている自然数であり、\emph{項数}（\emph{arity}）と呼ばれ、${\bm{f}^{(n)}}は${n}-項関数記号、${\bm{R}^{(m)}}は${m}-項関係記号と呼ばれる。
        特に、${0}-項関数記号は\emph{定数記号}と呼ばれ、メタ変数${\bm{c}_i, \bm{d}_i, \ldots}などで表す。

        一般に、記号の集合は有限とは限らず、任意の無限集合であったり、クラスであったりする場合がある。
      }

      +pn {
        一階の言語${\mathcal{L}}について、${\mathcal{L}}-\emph{項}（\emph{${\mathcal{L}}-term}）を以下のように帰納的に定義する：
        \enumerate{
          * 定数記号${\bm{c}}は${\mathcal{L}}-項である。
          * 変数${v}は${\mathcal{L}}-項である。
          * 関数記号${\bm{f}^{n}}および${\mathcal{L}}-項${\tau_0, \ldots, \tau_{n-1}}に対し、${\bm{f}(\tau_0, \ldots, \tau_{n-1})}は${\mathcal{L}}-項である。
          * 以上で定まるもののみが${\mathcal{L}}-項である。
        }
        最後の「以上で定まるもののみが〜」というのは、計算機科学でいう最小不動点の条件と同じである。以後の帰納的定義では省略する。
      }

      +pn{
        一階言語${\mathcal{L}}について、${\mathcal{L}}-\emph{原子論理式}（\emph{atomic ${\mathcal{L}}-formula}）を以下のように帰納的に定義する：
        \enumerate{
          * ${\bot}は${\mathcal{L}}-原子論理式である。
          * ${\tau, \tau'}が${\mathcal{L}}-項のとき、${\tau \mathrel{\bm{=}} \tau'}は${\mathcal{L}}-原子論理式である。
          * ${\bm{R}}が${m}-項関係記号、${\tau_0, \ldots, \tau_{m-1}}が${\mathcal{L}}-項のとき、${\bm{R}(\tau_0, \ldots, \tau_{m-1})}は${\mathcal{L}}-原子論理式である。
        }
      }

      +pn{
        古典一階述語論理の\emph{${\mathcal{L}}-論理式}（\emph{${\mathcal{L}}}-formula）を以下のように機能的に定義する：
        \enumerate{
          * ${\mathcal{L}}-原子論理式は${\mathcal{L}}-論理式である。
          * ${\varphi, \psi}が${\mathcal{L}}-論理式のとき、${\varphi \to \psi}は${\mathcal{L}}-論理式である。
          * ${x}が変数記号で${\varphi}が${\mathcal{L}}-論理式のとき、${\forall x \mhquad\varphi}は${\mathcal{L}}-論理式である。
        }
        自由変数\footnote{変数が自由とか束縛されているとかはみなさんが知っているやつです。}を持たない論理式を\emph{閉論理式}（\emph{closed formula}）または\emph{文}（\emph{sentence}）と呼ぶ。
      }
      +p{言語${\mathcal{L}}について、${\mathcal{L}}-論理式の全体のクラスを${\mathcal{L}}と書くことがある。}
      +p{
        ${\to}は右結合とする。つまり、${\varphi \to \psi \to \chi}は${\varphi \to (\psi \to \chi)}の略記として解釈される。
      }
    >

    +remark<
      +p{ここでは、オブジェクトレベルの演算・関係と区別するために、関数・関係記号を太字で表している。本節と次節では暫くこの区別を用いるが、慣れてきたら単に両者を混合して普通の字体で書く。}
    >

    +remark<
      +p{
        いま我々は古典論理だけを考えているので、他の論理結合子・量化子は次のような略記法として導入する：
        \gather?:(AZMathEquation.notag)(${|
          \lnot \varphi \deffml \varphi \to \bot, \mqquad \varphi \land \psi \deffml \lnot (\varphi \to \lnot \psi), \mqquad \varphi \lor \psi \deffml (\varphi \to \psi) \to \psi,
        | \exists x \varphi \deffml \lnot \forall x \lnot \varphi
        | \exists\! x \varphi \deffml \exists x \mhquad \pB{\varphi \land \forall y \mhquad \pb{\subst{\varphi}![(${x}, ${y})] \to y = x}}
        |});
        このようにするのは、今後論理式の複雑性に関する帰納法で色々な証明を回していく際に、場合分けの数は少ないほうが楽だからである。
      }
    >

    +p{一階の言語の例として、ここではこれからずっと付き合うことになる集合論の言語${\mathcal{L}_{\in}}や環の言語${\mathcal{L}_\text!({ring})}などを挙げておく：}

    +example?*?:({集合論の言語})<
      +p{集合論の言語${\mathcal{L}_{\in}}は、二項関係記号${\bold-in^{(2)}}のみを持つ言語である。}
    >

    +p{
      え？他の記号は要らないの？和集合とか内包表記とか……と思うかもしれないが、${\ZF}公理系は十分強力であり、そうした記号を含む論理式があっても、それを含まない形で書き換えることができる。例えば、${x = A \cup B}は${\forall z \mhquad \pB{z \bold-in x \lrarrow z \bold-in A \lor z \bold-in B}}と書き換えることができる。
    }

    +example?*?:({環の言語})<
      +p{単位的環の言語${\mathcal{L}_\text!{ring}}は定数記号${\bm{0}, \bm{1}}、二項関数号${\bold-plus, \bold-dot}を持つ言語である。}
    >

    +p{無限言語の例としては、体${K}に対して${K}-線型空間の言語がある：}

    +example?*?:({${K}-線型空間の言語})<
      +p{${K}を体とするとき、${K}-線型空間の言語は以下から成る：}
      +listing{
        * 定数記号${\bm{0}}
        * 二項関数記号${\bold-plus}
        * ${c \in K}ごとに、一項関数記号${\bm{c} \bold-dot}
      }
    >

    +p{
      以上はあくまで何が式で何が項かという構文を定義しただけである。それらの証明可能性を与えるのが\emph{証明体系}である。
      一階述語論理には互いに同値な複数の証明体系が知られている。型付き${\lambda}-計算に近い自然演繹${\NK}や、コンビネータ論理に近いヒルベルト流の体系${\HK}、簡潔でわかりやすく証明論などで用いられるシーケント計算${\LK}が代表的である。
    }

    +p{
      分析の対象としては${\LK}が洗練されているのだが、導入が簡単であり、強制法で扱う上でも楽なのでここではヒルベルト流の体系${\HK}を証明体系として採用することにする。
    }

    +defn?*?:({古典一階述語論理の証明体系${\HK}})<
      +p{
        定数記号の集合${A, B, C, \ldots}と変数記号の集合${x, y, z, \ldots}が与えられた時、これらから定まる\emph{${\CL}-項}（\emph{${\CL}-term}）を以下で定める：
        \enumerate{
          * 特別な定数${\K, \S}は${\CL}-項である。
          * 定数${A, B, C, \ldots}および変数は${x,y, z, \ldots}は${\CL}-項である。
          * ${L, M}を${\CL}-項とするとき、${(LM)}は${\CL}-項である。
        }
        変数を含まない${\CL}-項を\emph{閉${\CL}-項}と呼び、定数${\K, \S}のみから成る閉項を\emph{結合子}または\emph{コンビネータ}（\emph{combinator}）と呼ぶ。${\CL}-項の括弧は左結合とし、一番外側のものは省略する。つまり、${LM(NO)P}は${(((LM)(NO))P)}の略記である。
        ${\CL}-項を渡るメタ変数として、${L, M, N, \ldots}などを用いる。
      }
      +p{
        古典一階述語論理のヒルベルト流証明体系${\HK}を定義する。${\HK}-式は${\K}, ${\S}, ${\P}, ${\E_{\mathrm{refl}}}, ${\E_{\mathrm{symm}}}, ${\E_{\mathrm{trans}}}, ${\E_{\mathrm{subs}}}, ${\E_{\mathrm{cong}}}, ${\F}, ${\G}, ${\J}を定数として持つ${\CL}-項${L}と一階述語論理式${\varphi}に対して、${L: \varphi}の形のものである。${L}を主部または証明項、${\varphi}を述部または型と呼ぶ。

        ${\HK}は以下の公理図式を持つ：
        \listing{
          * \emph{公理図式}：
            
            ** ${\K: P \to Q \to P}
            ** ${\S: (P \to Q \to R) \to (P \to Q) \to P \to R}
            ** ${\A: \bot \to P}
            ** ${\P: ((P \to Q) \to P) \to P}
            ** ${\E_{\mathrm{refl}}: \forall x\mhquad x = x}
            ** ${\E_{\mathrm{symm}}: \forall x \forall y\mhquad \pB{x = y \to y = x}}
            ** ${\E_{\mathrm{trans}}: \forall x \forall y \forall z \mhquad \pB{x = y \to y = z \to x = z}}
            ** 任意の述語記号${\bm{R}^{(n)}}に対し：
              \eqn-notag(${\E_{\mathrm{subs}}: \forall x_0 \ldots \forall x_{n-1} \forall y_0 \ldots \forall y_{n-1} \mhquad \pB{x_0 = y_0 \to \ldots \to x_{n-1} = y_{n-1} \to \bm{R}(\bar{x}) \to \bm{R}(\bar{y})}});
            ** 任意の関数記号${\bm{f}^{(n)}}に対し：
              \eqn-notag(${\E_{\mathrm{cong}}: \forall x_0 \ldots \forall x_{n-1} \forall y_0 \ldots \forall y_{n-1} \mhquad \pB{x_0 = y_0 \to \ldots \to x_{n-1} = y_{n-1} \to \bm{f}(\bar{x}) = \bm{f}(\bar{y})}});

            ** ${\F: \p{\forall x P} \to \subst{P}![(${x}, ${\tau})]}（ただし${\tau}は${\mathcal{L}}-項）
            ** ${\G: \forall x \p{P \to Q} \to (P \to \forall x Q)}（ただし変数${x}は${P}に自由に現れない）
        }
      }
    >

    +p{
      これで${\HK}の公理は定まった。続いて${\HK}における「公理系」「証明」の概念を形式化しよう：
    }

    +defn?*?:({${\HK}の証明図})<
      +p{
        \enumerate{
          * ${\HK}における言語${\mathcal{L}}の公理系${\Gamma}とは、証明項がただ一つの定数のみからなる${\CL}-項で、述部が${\mathcal{L}}-閉論理式であるような${\HK}-項の集合である。
          * ${\HK}の\emph{証明図}とは、${\HK}-項を頂点とする根つき木であって、全ての枝が葉から根に向かって次の\emph{推論規則}のいずれかに従って形成されているものである。根を「\emph{結論}」、葉を「\emph{仮定}」と呼ぶ：
            ** \emph{三段論法}\footnote{厳密には、ギリシアのアリストテレス論理学における「三段論法」とは「大前提・小前提・結論」からなる（正しいとは限らない）論法の総称であり、モーダス・ポネンスはその中の妥当な典型例の一つである。だから、本来日本語訳として「三段論法」と呼ぶのは若干間違っており、厳密を期すのなら「前件肯定」と呼ぶべきだといえばそうなのだが、もう習慣として定着しているのでここでもそれに倣う。}（\emph{modus ponens}、${\MP}）：
              \eqn?:(AZMathEquation.notag)(open Derive in open DeriveDSL in ${
                \proven!(
                  derive ${(LM): Q}
                  |> byOp {${\MP}}
                  |> from [assume ${L: P \to Q}; assume ${M: P}]
                )
              });
            ** \emph{汎化}（\emph{generalization}）：
              \eqn?:(AZMathEquation.notag)(open Derive in open DeriveDSL in ${
                \proven!(
                  derive ${\J M: \forall x P}
                  |> byOp {${\Gen} \quad; （ただし仮定の述部に${x}は自由に現れない）}
                  |> from [assume ${M: P}]
                )
              });
          * 公理系${\Gamma}からの証明図は、仮定がすべて${\HK}の公理または${\Gamma}の公理である証明図のことである。
          * ${\HK}で公理系${\Gamma}から論理式${\varphi}が\emph{証明可能}（\emph{provable}、記号：${\Gamma \proves_{\HK} \varphi}）とは、結論が${\varphi}であるような${\Gamma}からの証明図が存在することである。
          * ${\varphi}が${\HK}の\emph{恒真式}（\emph{tautology}、記号${\proves_{\HK} \varphi}）とは、${\varphi}が${\emptyset}で証明可能であることである。
          * 公理系${T}が\emph{矛盾している}（\emph{inconsistent}）であるとは、${T \proves \bot}が成り立つこと、すなわち${T}から${\bot}への証明図が存在することである。
            矛盾していない公理系を\emph{無矛盾}（\emph{consistent}）であるといい、公理系${T}が無矛盾であることを記号${\Con(T)}で表す。。
        }
      }
    >
    +remark<+p{面倒なので、特に使わない場合は${\HK}の証明項を省略することがある。}>

    +p{次の結果は重要である：}

    +theorem<+p{${\HK}は無矛盾である。つまり、公理系${\emptyset}は無矛盾である。}>

    +p{
      標準的な証明は、${\HK}のメタ計算として見ることのできるGentzen流シーケント計算${\LK}を導入し、${\LK}-証明可能性と${\HK}-証明可能性の一致を証明してから、${\LK}のカット除去定理を示すことで行われる。
      今回はそんなことやってる暇はないし、使わないので省略する。
    }
    +exercise<+p{おるうぇくんに証明してもらおう！}>


    +example?*?:({二重否定除去})<
      +p{述語論理に立ち入る前に、この公理系から二重否定除去${\lnot \lnot P \to P}が証明可能であることを見てみよう（幅を取るので、${\lnot P \deffml P \to \bot}の略記法を使う）。以下がその証明図である：
      }
      
      +font-style[FssStyle.with-font-size (fun sz -> sz *' 0.75)]<+eqn-notag(open Derive in open DeriveDSL in ${
        \proven!(
          derive ${\S(\K\P)(\S(\K\A)): \lnot \lnot P \to P}
          |> byOp {${\MP}}
          |> from 
              [ derive ${\S(\K\P): (\lnot \lnot P \to (\lnot P \to P) \to P)
              \to (\lnot \lnot P \to \lnot P \to P)
              \to \lnot \lnot P
              \to P}
                |> byOp {${\MP}}
                |> from
                    [ derive ${\S: \gamma} 
                    ; derive ${\K\P: \lnot\lnot P \to (\lnot P \to P) \to P}
                      |> byOp {${\MP}}
                      |> from [derive ${\K: \xi}; derive ${\P: (\lnot P \to P) \to P}]
                    ]
              ; derive ${\S(\K\A): \lnot\lnot P \to \lnot P \to P}
                  |> byOp {${\MP}}
                  |> from 
                      [ derive ${S: \zeta}
                      ; derive ${\K\A: \lnot P \to \bot \to P}
                        |> byOp {${\MP}}
                        |> from [derive ${\K: \delta}; derive ${\A: \bot \to P}]
                      ]
              ]
        )
      });>

      +p{
        但し、
        \gather?:(AZMathEquation.notag)(${
          | \gamma \deffml (\lnot \lnot P \to (\lnot P \to P) \to P)
        \to (\lnot \lnot P \to \lnot P \to P)
        \to \lnot \lnot P
        \to P
          | \xi \deffml ((\lnot P \to P) \to P) \to \lnot\lnot P \to (\lnot P \to P) \to P
          | \zeta \deffml (\lnot P \to \bot \to P) \to (\lnot P \to \bot) \to \lnot P \to P
          | \delta \deffml  (\bot \to P) \to \lnot P \to \bot \to P
        |}
        );
      }
    >

    +p{このように、ちょっとした証明でも結構たいへんである。次の演繹定理を使うとある程度証明を楽できる：}

    +theorem?*?:({${\HK}の演繹定理})<
      +p{${\Gamma}を公理系、${\varphi, \psi}を論理式としたとき、${\Gamma, \varphi \proves_{\HK} \psi}ならば${\Gamma \proves_{\HK} \varphi \to \psi}。}
    >

    +p{この証明には、次の${\lambda}-抽象を使う：}

    +defn<
      +p{${M}を${\CL}-項、${x}を変数としたとき、${x}を含まない${\CL}-項${(\lambda x. M)}を${M}の構成による帰納法で次のように定義する：}
      +enumerate{
        * ${\lambda x. M \deffml \K M}, ただし ${x \nin \FV(M)}
        * ${\lambda x. x \deffml \S\K\K}
        * ${\lambda x. \J M \deffml \G(\J(\lambda x. M))} 
        * ${\lambda x. MN \deffml \S(\lambda x. M)(\lambda x. N)}
      }
    >

    +p{演繹定理はより詳しく次のように言い換えられる：}

    +theorem?*?:({${\HK}の演繹定理})<
      +p{${x}を${\Gamma}に現れない${\CL}-変数、としたとき、}
      +eqn-notag(${
        x: \varphi, \Gamma \proves_{\HK} M: \psi 
        \mquad \implies \mquad \Gamma \proves_{\HK} (\lambda x. M): \varphi \to \psi
      });
    >
    +cor?:(`not-intro`)<+p{${T, \varphi \proves \bot \implies T \proves \lnot \varphi}。}>

    +p{
      この${\lambda}-抽象は、理論計算機科学で\emph{${\lambda}-計算の項をコンビネータ論理にコンパイルする際に用いられる変換と同じもの}である。${\S, \K}といった項も、コンビネータ論理の基本的な項である。実は、上の二重否定除去の証明図は、最初にHaskellで同じ型を持つプログラムをでっちあげて、コンパイラに部分項の型推論をさせて復元して書いたものである。
      ${\HK}-項の定義の際に「型」という言葉を使ったように、実は直観主義論理の証明項・主部と、型付き${\lambda}-計算の項・型との間には対応関係があり、これを\emph{Curry–Howard対応}とよぶ。
      我々は\emph{古典}論理を考えているが、これは${\lambda}-計算に続きの計算を表す\emph{継続}を入れたものに対応しており、実は継続オペレータに型を付けようとすると、古典命題論理のトートロジーであるPeirceの法則${((P \to Q) \to P) \to P)}と一致し、これこそが上の公理系の${\P}である。Peirceの法則は直観主義論理に付け加えると、ちょうど古典論理と一致する。
    }


    +exercise<
      +p{上で導入した${\HK}から排中律${P \lor \lnot P}が証明可能であることを示せ。また、逆に${\HK}から${\P}を除いた体系に排中律・二重否定除去の一方だけを追加すると、${\P}が証明できることを示せ。}
    >

    +p{演繹定理の応用として、次の命題が示せる：}

    +lemma?:(`lem:consis-extend`)<
      +p{${\varphi}を閉論理式とする。公理系${T}が無矛盾なら、${T + \varphi}か${T + \lnot \varphi}の少なくとも一方は無矛盾。}
    >
    +proof<
      +p{
        まず${T + \varphi}が矛盾した場合を考える。このとき、有限個の${A_0, \ldots, A_{n-1} \in T}があって、${A_0, \ldots, A_{n-1}, \varphi \proves \bot}となる。
        特に、演繹定理の\ref(`not-intro`);から${A_0, \ldots, A_{n-1} \proves \lnot \varphi}が成り立ち、特に${T \proves \lnot \varphi}である。よって${\lnot \varphi}は${T}の帰結なので、${T + \varphi}は当然無矛盾である。
      }

      +p{
        逆に${A_0, \ldots, A_{n-1}, \lnot \varphi \proves \bot}とすると、同様にして${T \proves \lnot \lnot \varphi}が成り立つ。二重否定除去則${\HK}の定理であるので、再び演繹定理から${T \proves \varphi}を得る。
      }
    >

    +exercise<+p{上の証明を、${\HK}から${\P}を取り除いた直観主義論理の体系${\mathrm{HJ}}でも通るようにせよ。}>

    +lemma?:(`lem:unprovable`)<
      +p{${\HK}において、公理系${T}から${\varphi}が証明不能なら、${T + \lnot \varphi}は無矛盾。}
    >
    +proof<
      +p{${T}が矛盾していると、公理${\A: \bot \to P}より任意の論理式が証明可能となるので、仮定から${T}は無矛盾であることに注意する。}
      
      +p{
        ${T + \lnot \varphi}が矛盾していたとする。このとき再び\ref(`not-intro`);から${T \proves \lnot\lnot \varphi}である。二重否定除去は${\HK}の定理なので、結局${T \proves \varphi}となり、${T \nproves \varphi}に反する。
      }
    >

    +remark<+p{実は、この定理は${\mathrm{HJ}}では成立しない。この事を使って、直観主義論理上で「ゼロではなくはない冪零無限小元」を使って解析学を展開する\emph{滑らか無限小解析}（\emph{smooth infinitesimal analysis}）およびその上に構築された\emph{綜合的微分幾何学}（\emph{synthetic diferrential geometry}）という分野がある。}>

    +exercise?*?:({酒場の法則})<
      +p{
        古典一階述語論理のヘンなトートロジーとして有名なものに、一項関係記号${P}をもつ言語で表現できる「酒場の法則」がある：
        \eqn?:(AZMathEquation.notag)(${
          \exists z \mhquad[P(z) \to \forall x P(x)]
        });
        ${P(x)}を「${x}が呑んだくれている」と読むと、これが「酒場の法則」と呼ばれている理由がわかる：「どんな酒場にも、そいつが呑んだくれているなら、他の客も全員呑んだくれているような客${z}氏がいる」。
        演繹定理を駆使して、${\HK}でこの法則を示せ。
      }

      +pn{\font-style[bold]{ヒント：呑んでない人間がいるならそいつを${z}氏とし、全員呑んでいるなら適当に取ればよい。}}
    >
    +subsection{定義による拡張}<
      +p{
        ${\mathcal{L}}-公理系${T}が与えられたとき、${T}から存在が証明できる関数があったとしても、${\mathcal{L}}にそれを指す関数記号があるとは限らない。
        しかし、我々は日常的に「関数」を定義して変数に束縛し、それを以後自由に使う、というようなことをする。これは、公理系の\emph{定義による拡張}と呼ばれる操作として正当化される：
      }
      +defn?*?:({定義による拡張})<
        +p{${T}を${\mathcal{L}}-理論とする。}
        +enumerate{
          * ${\varphi(x_0, \ldots, x_{n-1})}を ${\mathcal{L}}-論理式とする。この時言語${\mathcal{L}}に含まれない新たな関係記号${\bm{R}^{(n)}}を追加した言語${\mathcal{L}'}を考える。
            このとき、${\mathcal{L}'}-理論${T'}を、次で定義する：
            \eqn-notag(${
              T' \defeq T \cup \pb{ \forall \bar{x}\mhquad \pB{R(\bar{x}) \liff \varphi(\bar{x})} }
            });
            これを${\varphi}による${T}の\emph{定義による拡張}（\emph{definitional extension}）と呼ぶ。
          * ${\varphi(x_0, \ldots, x_{n-1}, y)}を ${\mathcal{L}}-論理式とし、
            \eqn-notag(${T \proves \forall \bar{x} \mhquad \exists\! y \mhquad \varphi(\bar{x}, y)});
            が成り立つとする。この時言語${\mathcal{L}}に含まれない新たな関数記号${\bm{f}^{(n)}}を追加した言語${\mathcal{L}'}を考える。
            このとき、${\mathcal{L}'}-理論${T'}を、次で定義する：
            \eqn-notag(${
              T' \defeq T \cup \pb{ \forall \bar{x}\mhquad \forall y\mhquad \pB{f(\bar{x}) = y \liff \varphi(\bar{x}, y)} }
            });
            これも${\varphi}による${T}の\emph{定義による拡張}（\emph{definitional extension}）と呼ぶ。
        }
      >
      +p{直感的には、この拡張によって証明能力や表現力は変わらないことが期待される。こういった関係を\emph{保存拡大}という：}
      +defn<+p{
        ${\mathcal{L} \subseteq \mathcal{L}'}を言語、${T, T'}をそれぞれ言語${\mathcal{L}, \mathcal{L'}}による理論とする。${T'}が${T}の\emph{保存拡大}（\emph{conservative extension}）であるとは、任意の${\mathcal{L}}-論理式${\varphi}について、次が成り立つことである：
        \eqn-notag(${
          T \proves \varphi \iff T' \proves \varphi.
        });
      }>
      +lemma<
        +p{}
        +enumerate{
          * 関係記号に関する定義による拡張は保存拡大である。より詳しく、任意の${\mathcal{L}'}-論理式${\varphi}に対して${\mathcal{L}}-論理式${\varphi^*}が存在して、
            \eqn-notag(${
              T' \proves \varphi \liff \varphi^{*},
              \mqquad T' \proves \varphi \iff T \proves \varphi^{*}.
            });
          * 関数記号に関する定義による拡張は保存拡大である。より詳しく、任意の${\mathcal{L}'}-論理式${\varphi}に対して${\mathcal{L}}-論理式${\varphi^*}が存在して、
            \eqn-notag(${
              T' \proves \varphi \liff \varphi^{*},
              \mqquad T' \proves \varphi \iff T \proves \varphi^{*}.
            });
        }
      >
      +exercise<+p{証明せよ。関数版の場合は、入れ子になった項に注意。}>
    >
  >

  +section?:(`chap:semantics`){一階述語論理のTarski意味論}<
    +p{前節で、言語${\mathcal{L}}の下での一階述語論理の構文と証明体系を導入した。これを具体的な数学の宇宙の対象と結び付け、解釈を考えるのが\emph{Tarski意味論}あるいは単純に${\mathcal{L}}-構造や「モデル」と呼ばれるものである。他にも色々なモデルの与え方はある（例えば強制法のBoole値モデルであるとか、圏論的論理学における函手など）し、意味論といっても結合子の間の調和を考える証明論的意味論など色々なものがあるが、以下ではモデルといったらTarskiモデルを考える。}

    +p{言語${\mathcal{L}}の項・論理式を解釈できる集合を${\mathcal{L}}-構造と呼ぶ：}

    +defn?*?:({${\mathcal{L}}-構造})<
      +p{
        言語${\mathcal{L} = \pangle{\bm{R}_i^{(n_i)}, \bm{f}_j^{(m_j)} }_{i \in I, j \in J}}
        について、\emph{${\mathcal{L}}-構造}（\emph{${\mathcal{L}}-structure}）とは、${\mathcal{M} = \pangle{M, R^{\mathcal{M}}_i, f^{\mathcal{M}}_j}}であって、次を満たすもの：
        \enumerate{
          * ${\mathcal{M} \neq \emptyset}
          * ${R^{\mathcal{M}}_i \subseteq M^{n_i}}は${M}上の${n_i}-項関係
          * ${f^{\mathcal{M}}_j: M^{m_j} \to M}は${M}上の${m_j}-引数関数
        }
      }
    >

    +p{台集合上の語彙の解釈がそれぞれ自然な方法で与えられているという訳で、代数系の定義を（公理を除いて）一般化したようなものになっている。}
    +p{単純な${\mathcal{L}}-言語だけでは、定数だけを含む論理式しか考えられないが、${\mathcal{L}}-構造${\mathcal{M}}が与えられたら、${\mathcal{M}}に含まれるような元についてもパラメータとして記述したくなる。そこで、${\mathcal{L}}-言語を拡大した言語${\mathcal{L}(\mathcal{M})}を定義しよう：}
    +defn<
      +p{${\mathcal{L}}を言語、${\mathcal{M}}を${\mathcal{L}}-構造とするとき、全ての${a \in \mathcal{M}}について、${\mathcal{L}}に含まれない新たな定数記号${\bm{c}_a}を付け加えた言語を、${\mathcal{L}}の${\mathcal{M}}による\emph{拡大}（\emph{expansion}）${\mathcal{L}(\mathcal{M})}と表す。
      }
    >
    +remark<+p{任意の${\mathcal{L}}-論理式は${\mathcal{L}(\mathcal{M})}-論理式でもある。}>
    +p{構造が定まると、自然な形で項・論理式の解釈も定まる：}

    +defn<
      +p{以下、${\mathcal{M}}を${\mathcal{L}}-構造とする。}
      +listing{
        * ${\mathcal{L}(\mathcal{M})}-項${\tau}について、以下のように${\tau}の${\mathcal{M}}における\emph{解釈}（\emph{interpretation}）を、項の構造に関する帰納法で以下のように定める：
          \enumerate {
            * 定数記号${\bm{c}_a\mhquad(a \in \mathcal{M})}に対し、${\bm{c}_a^\mathcal{M} \defeq a}
            * 関数記号${\bm{f}^{(m)}}と項${t_0, \ldots, t_{m-1}}に対し：
                \eqn-notag(${\p{\app{\bm{f}}{t_0, \ldots, t_{m - 1}}}^\mathcal{M} \defeq f^\mathcal{M}(t_0^\mathcal{M}, \ldots, t_{m - 1}^\mathcal{M})});
          }
        * ${\mathcal{L}(\mathcal{M})}-閉論理式${\varphi}について、${\mathcal{M} \models \varphi}を以下のように帰納的に定める：
        \enumerate{
            * ${\mathcal{M} \nmodels \bot}
            * 項${t_0, t_1}について、 ${\mathcal{M} \models t_0 = t_1 \defs t_0^\mathcal{M} = t_1^\mathcal{M}}
            * 関係記号${\bm{R}^{(n)}}と項${t_0, \ldots, t_{n-1}}に対し、${\mathcal{M} \models \bm{R}(t_0, \ldots, t_{n-1}) \defs (t_0^\mathcal{M}, \ldots, t_{n_i-1}^\mathcal{M}) \in R^\mathcal{M}}
            * ${\varphi, \psi}を${\mathcal{L}}-論理式とするとき、${\mathcal{M} \models \varphi \to \psi \defs \mathcal{M} \nmodels \varphi \lor \mathcal{M} \models \psi}
            * ${\varphi}を${\mathcal{L}}-論理式とするとき、
              ${\mathcal{M} \models \forall x \varphi
                \defs} 任意の${a \in \mathcal{M}}について${\mathcal{M} \models \subst{\varphi}![(${x}, ${\bm{c}_a})]
              }
          }
      }
    >
    +p{${T}を${\mathcal{L}}-公理系としたとき、いよいよ${T}-モデルの定義ができる：}

    +defn<
      +p{${T}を${\mathcal{L}}-公理系、${\mathcal{M}}を${\mathcal{L}}-構造、${\varphi}を${\mathcal{L}}-論理式とする。}
      +listing{
        * ${\mathcal{M}}が${T}の\emph{モデル}（\emph{model}）である（記号：${\mathcal{M} \models T}）${\defs}任意の${\varphi \in T} \footnote{${\HK}の公理系は厳密にはラベルつきの閉論理式の集合であった。以下では、ラベルを無視して論理式だけを見る。}について${\mathcal{M} \models \varphi}。
        * ${\varphi}が${T}で\emph{妥当}（\emph{valid}）である${T \models \varphi} ${\defs} 任意の${\mathcal{L}}-構造${\mathcal{M}}について${\mathcal{M} \models T \implies  \mathcal{M} \models \varphi}。
      }
    >
  >

  +section?:(`chap:models`){モデルの性質：モデルの濃度とモデル間の真理の比較、完全性定理}<
    +subsection{初等性と絶対性、Tarski–Vaughtの判定条件}<
      +p{前節では${\mathcal{L}}-構造を定義したが、今回はその複数のモデル同士を比べたり、あるいは新しいモデルを構成する方法について取り扱う。}
      +p{まず、部分環や部分空間などのように、大きなモデルの部分に相当する部分構造（部分モデル）を定義する：}
      +defn<
        +p{${\mathcal{L}}-構造${\mathcal{M}, \mathcal{N}}について、${\mathcal{N}}が${\mathcal{M}}の\emph{部分構造}（\emph{substructure}）または${M}が${N}の\emph{拡大}（\emph{extension}）${\defs}
          \enumerate{
            * ${\mathcal{N} \subseteq \mathcal{M}}、
            * 任意の関係記号${\bm{R}^{(n)}}について${R^\mathcal{N} = R^\mathcal{M} \cap N^{n}}、
            * 任意の関数記号${\bm{f}^{(m)}}について${f^\mathcal{N} = f^\mathcal{M} \restrict N^{m}}。
          }
        }
      >
      +remark<+p{背景となる理論がある程度固定されている場合、「部分モデル」（submodel）とも呼ぶ。}>
      +p{
        つまり、関係は制限したものになっており、関数の解釈について閉じているような関係である。
        さらに、論理式の解釈についても閉じているような部分・拡大構造を初等部分モデル・初等拡大とよぶ：
      }
      +defn?*?:({絶対性、初等部分構造})<
        +p{${\mathcal{N} \subseteq \mathcal{M}}を${\mathcal{L}}-構造とし、${\mathcal{N}}は${\mathcal{M}}の部分構造であるとする。}
        +listing{
          * ${\mathcal{L}(N)}-論理式${\varphi}が${\mathcal{N}}と${\mathcal{M}}の間で\emph{絶対的}（\emph{absolute}、記号：${\mathcal{N} \prec_{\varphi} \mathcal{M}}）${\defs} ${\mathcal{N} \models \varphi} iff ${\mathcal{M} \models \varphi}。
          * ${\mathcal{L}(N)}-論理式の集合${\Gamma}について、${\Gamma}が${N}と${M}の間で\emph{絶対的}（${N \prec_\Gamma M}）${\defs}任意の${\varphi \in \Gamma}について${\mathcal{N} \prec_{\varphi} \mathcal{M}}。
          * ${\mathcal{N}}が${\mathcal{M}}の\emph{初等部分構造}（\emph{elementary substructure}）または${\mathcal{M}}が${\mathcal{N}}の\emph{初等拡大}（\emph{elementary extension}）である（記号：${\mathcal{N} \prec \mathcal{M}}）とは、${\mathcal{N} \prec_{\mathcal{L}(\mathcal{N})} \mathcal{M}}のこと。
        }
      >
  
      +remark<+p{一般に、「初等××」という概念の「初等」は、「一階述語論理の」というような意味である。}>
  
      +p{以上は部分モデル上の初等性だが、良く似た概念に部分モデル関係が成り立つとは限らない構造間の初等同値性がある：}
  
      +defn<
        +p{${\mathcal{L}}-構造${\mathcal{M}, \mathcal{N}}が${\mathcal{L}}-\emph{初等同値}（\emph{elementarily equivalent}、記号：${\mathcal{M} \equiv_{\mathcal{L}} \mathcal{N}}）${\defs} 任意の${\mathcal{L}}-閉論理式${\varphi}について${\mathcal{M} \models \varphi} iff ${\mathcal{N} \models \varphi}。}
      >
  
      +p{つまり、初等拡大性${\mathcal{N} \prec \mathcal{M}}は、${\mathcal{N}}が${\mathcal{M}}の部分構造であり、${\mathcal{N} \equiv_{\mathcal{L}(\mathcal{N})} \mathcal{M}}
      であるということだ。}
  
      +exercise<+p{部分構造だが、初等部分構造ではないような例を挙げよ。}>
      +exercise<+p{言語によって（初等）部分構造であったりなかったりする構造の組の例をそれぞれ挙げよ。}>
  
      +p{次の\emph{Tarski–Vaught判定条件}は初等性を判定する上で最頻出の道具であり、初等拡大であるかどうかというのは、解が小さいところから取れるかどうか？という問題と同値であることを述べている：}
  
      +lemma?:(`lem:Tarski-Vaught`)?:({Tarski–Vaught判定条件})<
        +p{${\mathcal{N} \subseteq \mathcal{M}}を${\mathcal{L}}-部分構造とするとき、次は同値：}
        +enumerate{
          * ${\mathcal{N} \prec \mathcal{M}}
          * ${\varphi(x)}を${x}のみを変数に持つ${\mathcal{L}(\mathcal{N})}-論理式とするとき、
            \eqn-notag(${\mathcal{M} \models \pB{\exists x\varphi(x)} \implies \exists a \in \mathcal{N} \mhquad \mathcal{M} \models \varphi(a) });
        }
      >
      +remark<+p{「解」${a \in \mathcal{N}}そのものは小さい${\mathcal{N}}の方から取っているが、その真偽の判定は大きな${\mathcal{M}}の方で成り立っているかどうかだけ考えればよい、という点に注意しよう。}>
      +exercise<
        +p{上を証明せよ。（\font-style[bold]{ヒント：論理式の複雑性に関する帰納法。）}}
      >
      +p{Tarski–Vaught判定条件の系である、次の\emph{初等鎖定理}もよく使う：}
      +lemma?*?:({初等鎖定理})<
        +p{${\Seq{M_\alpha}{\alpha < \gamma}}を${\mathcal{L}}-構造の列とし、更に任意の${\alpha < \beta}について${M_\alpha \prec M_\beta}が成り立つする。このとき、${M \defeq \bigcup_\alpha M_\alpha}とおけば、${M_\alpha \prec M}が任意の${\alpha < \gamma}について成り立つ。}
      >
      +exercise<+p{示せ。部分構造になることがちゃんと言えれば、あとは簡単。}>
  
      +p{
        初等部分構造や初等拡大を取ったりして色々するのは、モデル理論や集合論の基本的な操作である。以下では、そうした構成の道具を見ていく。
      }
    >
    +subsection{超積と超冪によるモデルの構成とŁośの定理}<
      +p{
        \emph{超積}は添え字づけられたモデルの族が与えられた際に、そこから新たなモデルを構成する方法であり、更に最終的に得られるモデルは「殆んど至るところ」で成り立つ真理を反映したものになっている。更に、\emph{超冪}は超積の特別な場合であり、添え字に依らず同じ構造を使って超積をとったものだが、これは強制法や巨大基数の理論の非常に重要な道具である。
      }

      +p{
        超積は、冪集合の成すBoole代数上の超フィルターを使って定義される。
        （超）フィルターの定義は前回やった通りだが、考えている擬順序が冪集合代数のようにBoole代数であるとき、定義がより簡単になる：
      }
        
      +lemma<
        +p{${\mathbb{B}}をBoole代数、${\mathcal{F}\subseteq \mathbb{B}}とするとき、次は同値：}
        +enumerate{
          * ${\mathcal{F}}は${\mathbb{B}}のフィルター。
          * 以下が成り立つ：
            ** ${\mathbb{0} \nin \mathcal{F}, \mathbb{1} \in \mathcal{F}}
            ** ${\mathcal{F} \ni b \leq c \implies c \in \mathcal{F}}
            ** ${b, c \in \mathcal{F} \implies b \cdot c \in \mathcal{F}}
        }
      >
      +lemma<
        +p{${\mathbb{B}}をBoole代数、${\mathcal{U}}を${\mathbb{B}}のフィルターとするとき、次は同値：}
        +enumerate{
          * ${\mathcal{U}}は${\mathbb{B}}の超フィルター。
          * 任意の${b \in \mathbb{B}}について、${b \in \mathcal{U}}または${- b \in \mathcal{U}}のいずれか一方のみが成り立つ。
        }
      >
      +defn<+p{\emph{集合${I}上の（超）フィルター}（\emph{(ultra-)filter on } ${I}）とは、冪集合Boole代数${(\Pow(I), \emptyset, I, (-)^c, \cup, \cap\subseteq)}の（超）フィルターのことである。}>

      +remark<+p{前回のチュートリアルでは、フィルターは貼り合わせ可能な条件の集合であり、超フィルターは極限まで条件を突き詰めたものだという見方をした。
      一方で、フィルターは「殆んど至るところで成り立つ」ような何らかの性質を表現するのにも使うことができる。}>

      +example<+p{}
        +enumerate{
          * 測度空間上の零集合の集まり${\null}を考える。このとき、${\null^* \defeq \Set{A \subseteq X}{ X \setminus A \in \null}}はボレル集合族${\mathcal{B}}のフィルターである。
          * 完備距離空間${(X, d)}を考える。この時、${X}の稠密開集合全体は開集合代数上のフィルターを成す。別の見方をすれば、${X}上でフィルター基になっている。
          * 位相空間${(X, \mathcal{O})}の近傍系${\mathcal{U}_x = \Set{A \subseteq X}{x \in X^{\circ}}}は${X}上のフィルターを成す。基本近傍系はフィルター基になっている。
          * ${\mathcal{F}_{\mathrm{cofin}} \defeq \Set{S \subseteq X}{\pabs{X \setminus S} < \aleph_0}}は集合${X}上のフィルターとなる。\emph{補有限フィルター}（\emph{cofinite filter}）や\emph{\ruby[`フレシェ`]{|Fréchet|}フィルター}と呼ぶ。
        }
      >

      +defn<
        +p{
          ${I}を任意の集合とし、${\Seq{\mathcal{M}_i}{i \in I}}を${\mathcal{L}}-構造の族、${\mathcal{U}}を${I}上の超フィルターとする。
        }
        +listing{
          * ${u, v \in \prod_{i \in I} \mathcal{M}_i}に対して、${u \sim_{\mathcal{U}} v}を次で定める：
            \eqn-notag(${u \sim_{\mathcal{U}} v \defs \Set{i \in I}{u(i) = v(i)} \in \mathcal{U}});
            このとき、${[u]_{\mathcal{U}}}を${\sim_{\mathcal{U}}}に関する${u \in \prod_i \mathcal{M}_i}の同値類とする。
          * ${\pangle{\mathcal{M}_i}_{i \in I}}の${\mathcal{U}}による\emph{超積}（\emph{ultraproduct}）${\mathcal{N} = \quot{\prod_{i \in I} \mathcal{M}_i}{\mathcal{U}}}とは、次で定義される${\mathcal{L}}-構造である。
            \enumerate{
              * \emph{台集合}：
                \eqn-notag(${\quot{\prod_{i \in I} \mathcal{M}_i}{\mathcal{U}} \defeq \Set{[u]_{\mathcal{U}}}{u \in \prod_{i \in I} \mathcal{M}_i}});
              * \emph{関係記号の解釈}：各${\bm{R}^{(n)}}について、
                \eqn-notag(${
                  ([u_0], \ldots, [u_{n-1}]) \in R^{\mathcal{N}} 
                    \defs
                  \Set{i \in I}{(u_0(i), \ldots, u_{n-1}(i)) \in R^{\mathcal{M}_i}} \in \mathcal{U}
                });
              * \emph{関数記号の解釈}：各${\bm{f}^{(m)}}について、
                \eqn-notag(${
                  f^{\mathcal{N}}([u_0], \ldots, [u_{m-1}]) 
                    \defeq
                  \pB{\Seq{f^{\mathcal{M}_i}(u_0(i), \ldots, u_{m-1}(i))}{i \in I}}_\mathcal{U}
                });
            }
          * ${\mathcal{M}_i= \mathcal{M}}のとき、${\quot{\prod_{i\in I}\mathcal{M}}{\mathcal{U}}}を${\mathcal{M}}の${\mathcal{U}}による\emph{超冪}（\emph{ultrapower}）と呼び、記号${\ultpow{I}{\mathcal{M}}{\mathcal{U}}}で表す。
        }
      >

      +exercise<+p{超積${\quot{\prod_i \mathcal{M}_i}{\mathcal{U}}}の定義がwell-definedであり、実際に${\mathcal{L}}-構造となることを示せ。}>

      +p{
        超積が「殆んど至るところ成立する」ものを集めてきたものだ、といったが、そのことを表現しているのが、次の\ruby[`ウロッシュ`]{|Łoś|}\footnote{Łośはポーランド人の数学者である。ŁはWとLの中間音（そんなのある？）、śは「シュ」みたいに発音するらしい。}の定理である：}

      +theorem?*?:({Łośの定理})<
        +p{${\mathcal{L}\p{\quot{\prod_i \mathcal{M}_i}{\mathcal{U}}}}-論理式${\varphi}について、次が成立：}
        +eqn-notag(${
          \quot{\prod_{i \in I} \mathcal{M}_i}{\mathcal{U}} \models \varphi
            \iff \Set{i \in I}{ \mathcal{M}_i \models \varphi} \in \mathcal{U}
        });
      >
      +proof<
        +p{
          超積についてはほとんどの参加者が知らないようなので、ここでは軽く証明の概略を示しておく。
          \eqn-notag(${\mathcal{M} \defeq \quot{\prod_i\mathcal{M}_i}{\mathcal{U}}});
          とおいて、${\mathcal{L}(\mathcal{M})}論理式${\varphi}の複雑性に関する帰納法を使って示す。
        }

        +p{${\varphi}が関係記号のときは定義から明らか。}

        +p{
          ${\varphi \equiv \forall x \psi(x)}のときを考える。帰納法の仮定は、任意の${[u] \in \mathcal{M}}について

          \eqn-notag(${
            \mathcal{M} \models \psi([u]) \iff \Set{i \in I}{\mathcal{M}_i \models \psi(u(i))} \in \mathcal{U}
          });
    
          である。しかるに：
          \alignat?:(AZMathEquation.notag)(2)(${|
            \mathcal{M} \models \forall x \psi(x)
              | \iff \forall [u] \in \mathcal{M} \mhquad \mathcal{M} \models \varphi([u]) | \mquad | (\text!{${\models}の定義})
          | | \iff \forall [u] \in \mathcal{M} \mhquad  \Set{i \in I}{\mathcal{M}_i \models \psi(u(i))} \in \mathcal{U} |  | (\text!{帰納法の仮定}) 
          || \iff \Set{i \in I}{ \forall [u] \in \mathcal{M}\mhquad \mathcal{M}_i \models \psi(u(i))} \in \mathcal{U} || (\ast)
          || \iff \Set{i \in I}{ \mathcal{M}_i \models \forall x \psi(x)} \in \mathcal{U} | | (\text!{各${M_i \neq \emptyset}、${\mathcal{M}_i \models \forall}の定義より})
          |});
          ${(\ast)}の部分に詳しい説明が必要だろう。
          }
          +p{
            ${(\Longleftarrow)}の向き：定義より、
            \eqn-notag(${
              \Set{i \in I}{ \forall [u] \in \mathcal{M}\mhquad \mathcal{M}_i \models \psi(u(i))} = \bigcap_{[v] \in \mathcal{M}} \Set{i \in I}{ \mathcal{M}_i \models \psi(v(i))} 
            });
            である。いま、任意の${[u] \in \mathcal{M}}について
            \eqn-notag(${
              \mathcal{U} \ni \bigcap_{[v] \in \mathcal{M}} \Set{i \in I}{ \mathcal{M}_i \models \psi(v(i))}  \subseteq \Set{i \in I}{ \mathcal{M}_i \models \psi(u(i))} 
            });
            であり、${\mathcal{U}}はフィルター、特に上に閉じているから、${\Set{i \in I}{ \mathcal{M}_i \models \psi(u(i))} \in \mathcal{U}}を得る。
          }
        +p{
          ${(\implies)}の向き：ここで超フィルターであることを使う。仮に、
          \eqn-notag(${\Set{i \in I}{ \forall [u] \in \mathcal{M}\mhquad \mathcal{M}_i \models \psi(u(i))} \nin \mathcal{U}});
          であったとする。このとき、超フィルターの極大性から、この補集合は${\mathcal{U}}に属する：
          \eqn-notag(${
            S \defeq 
            \Set{i \in I}{ \exists [u] \in \mathcal{M}\mhquad \mathcal{M}_i \nmodels \psi(u(i))} \in \mathcal{U}
          });
          ${\emptyset \nin \mathcal{U}}より${S \neq \emptyset}であることに注意する。
          ここで、${[v] \in \mathcal{M}}を以下のように定める：
          \eqn-notag(${
            v(i) \defeq
            \cases!(${|u(i)\mathrel{\text!{for}} [u] \in \mathcal{M} \mathrel{\text!{with}} \mathcal{M}_i \nmodels \psi(u(i))|(i \in S)| \text!{任意の} x \in \mathcal{M}_i |(\text!{otherwise})|})
          });
          すると、各${i \in S}について${\mathcal{M}_i \nmodels \psi([v])}がなりたっているので、帰納法の仮定より${\mathcal{M} \nmodels\psi([v])}となる。しかし、${(\ast)}の直前の仮定から${T \defeq \Set{i \in I}{\mathcal{M}_i \models \psi(v(i))} \in 𝒰}である。
          ${𝒰}はフィルターであり、${S \cap T \in 𝒰 \nni \emptyset}なので、${i \in S \cap T}が取れる。
          しかし、すると${S}の定義から${\mathcal{M}_i \nmodels \psi(v(i))}、${T}の定義から${\mathcal{M}_i \models \psi(v(i))}となり、矛盾。
        }
      >
      +exercise<+p{${\to}, ${\bot}などの場合を補い、上の証明を完成させよ。}>

      +cor<+p{${\mathcal{M}}を${\mathcal{L}(\mathcal{M})}-構造と思って超冪を取ると、
        \eqn-notag(${
          \mathcal{M} \prec \ultpow{I}{\mathcal{M}}{\mathcal{U}}.
        });
      }>
      +proof<
        +p{
          ${\varphi}を${\mathcal{L}(\mathcal{M})}-論理式とすると、任意の${i}につき${M_i = M}なので、
          \eqn-notag(${
            \Set{i \in I}{\mathcal{M}_i \models \varphi} = 
              \cases!(${| I | (\mathcal{M} \models \varphi)
                        | \emptyset | (\text!{otherwise})|}
                      )
          });
          よって${\mathcal{M} \models \varphi \iff \Set{i \in I}{\mathcal{M} \models \varphi} = X \in \mathcal{U} \mathrel{\overset{\text!{Łoś}}{\iff}} \ultpow{I}{\mathcal{M}}{\mathcal{U}} \models \varphi}を得る。
        }
      >

      +p{
        Łośの定理を使うには、超フィルターを取る必要がある。我々は${\AC}を仮定しているので、どんな集合上にも必ず超フィルターが取れる：
      }
      +lemma?*?:({Boolean Prime Ideal Theorem, ${\BPI}})<
        +p{${\mathcal{F} \subseteq \mathbb{B}}をBoole代数のフィルターとするとき、それを拡張する超フィルターが少なくとも一つ存在する。}
      >
      +exercise<+p{これを証明せよ（\font-style[bold]{ヒント：フィルターを一歩一歩拡張していけばいいだけ}）}>
      +remark<+p{実は、${\BPI + \text!{Łoś}}は選択公理と同値である。}>
      +p{フィルターのうち上閉性を外したものをフィルター基というのであった。フィルター基が与えられたとき、その元以上のものを全て集めてくればフィルターになるので、次の系が得られる：}
      
      +cor<
        +p{${A \subseteq \mathbb{B}}をBoole代数のフィルター基とするとき、それを拡張する超フィルターが少なくとも一つ存在する。}
      >
    >
    +subsection{超積の応用1：コンパクト性定理}<
      
      +p{超積なんて何に使うのか？と思うかもしれない。しかし、これは非常に強力な道具であり、例えばモデル理論の最も基本的な定理である、コンパクト性定理や完全性定理の証明に使うことができる。}

      +theorem?*?:({コンパクト性定理\footnote{名前の通り、この定理はモデルの空間にしかるべき位相を入れたときに、その空間がコンパクトであることと同値である。}})<
        +p{公理系${T}がモデルを持つことと、${T}の任意の有限部分集合がモデルを持つことは同値である。}
      >

      +proof?:({Proof of Compactness Theorem})<
        +p{${T}がモデルを持つなら、当然それは${T}の有限部分のモデルになっている。逆を示そう。}
        +p{
          そこで、${T}の任意の有限部分集合${s \Subset T}がモデルを持つとし、それぞれに対して${M_s \models s}となるモデルを固定する。
          添え字集合は${T}の有限部分集合なので、${I \defeq [T]^{<\aleph_0} \defeq \Set{x \subset T}{\pabs{T} < \aleph_0}}とおいて、${I}上の超フィルターでいいものを取りたい。
        }

        +remark<
          +p{${I}じたいも有限集合の族だが、取るのは${I}上の超フィルター${\mathcal{U}}、いいかえれば${\Pow(I)}の部分集合である。つまり、\emph{${\mathcal{U}}の各元${S \in \mathcal{U}}は${T}の有限集合ではなく}、${T}の有限部分集合を元にもつ無限集合である。
          ここを混同すると、どこの話をしているのかわからなくなる。}
        >

        +p{
          各${s}について、集合${V_s \subseteq I}を以下で定める：
          \eqn-notag(${
            V_s \defeq \Set{X \in I}{s \subseteq X}
          });
          このとき、${\mathcal{B} \defeq \Set{V_s}{s \in I}}はフィルター基となる。
          なぜなら、${V_s \neq \emptyset}であり、また${V_s \cap V_t = V_{s \cup t} \in \mathcal{B}}となるからである。
          そこで、${\BPI}により${\mathcal{B} \subseteq \mathcal{U}}なる${I}上の超フィルターを取り、${M \defeq \quot{\prod_{i \in I} M_i}{\mathcal{U}}}と定めよう。
        }

        +pn{\font-style[bold]{Claim}. ${M \models T}である。}

        +p{
          そこで、任意に${\varphi \in T}を取り、${M \models \varphi}を示す。Łośの定理から、次を示せばよい：
          \eqn-notag(${
            S \defeq \Set{s \in I}{M_s \models \varphi} \in \mathcal{U}.
          });
          まず、構成法より${V_{\pb{\varphi}} \in \mathcal{B} \subseteq \mathcal{U}}である。
          ここで、任意に${s \in V_{\pb{\varphi}} \subseteq [T]^{<\aleph_0}}を取る。${s}は${T}の有限部分集合であり、更に${\varphi}を元にもつ。よって${M_s \models \varphi}がなりたつ。
          以上から、
          \eqn-notag(${
            S = \Set{s \in I}{M_s \models \varphi} \supseteq V_{\pb{\varphi}} \in \mathcal{U}
          });
          いま${\mathcal{U}}はフィルターで上に閉じているから、結局${S \in \mathcal{U}}となる。
        }
      >
    >
    +subsection{完全性定理：証明体系と意味論を繋ぐもの}<
      +p{
        さて、前節では、${\mathcal{L}}-構造や公理系${T}のモデルについて定義をし、「全ての${T}のモデルで成り立つ」という意味論的な妥当性を定義した：
        \eqn-notag(${
          T \models \varphi \defs \forall \mathcal{M} \models T \mhquad \mathcal{M} \models \varphi
        });
        一方で、我々は証明体系${\HK}における証明可能性、
        \eqn-notag(${
            T \proves \varphi
        });
        も既に扱っていた。この二つの概念が一致することを示すのが\emph{完全性定理}（\emph{Completeness Theorem}）である：
      }
      +theorem?*?:({一階述語論理の完全性定理、Gödel (1929) の学位論文})<
        +p{${T \models \varphi \implies T \proves \varphi}}
      >
      +p{
        この逆向き、つまり「証明可能なら、妥当である」の方向については\emph{健全性定理}（\emph{Soundness Theorem}）と呼ばれることも多い。「成り立たないような命題が証明されてしまうようなヘンな証明体系ではない」という意味で「健全」ということである。
      }
      +exercise<
        +p{健全性定理${T \proves \varphi \implies T \models \varphi}を証明せよ。}
        +font-style[bold]<
          +pn{ヒント：証明図の深さに関する帰納法。固有変数条件が効いてくる。}
        >
      >
      +p{
        健全性は地道にやればできるが、完全性${T \models \varphi \implies T \proves \varphi}は非自明である。完全性が「完全性」と呼ばれるのは、「全部のモデルで成り立つような命題を完全に取り尽せている」という気持ちが背景にある。
        これは一般に対偶を示すのが常套手段である。つまり、${\varphi}が${T}から証明できないとして、${M \models \lnot \varphi}なる${T}-モデル${M}を構成するのだ。
        この証明には、一般的には\emph{Henkin構成}と呼ばれる手法が使われるが、実は可算言語に関する完全性さえ示せれば、後は上記のコンパクト性定理を使って証明できてしまう。
      }

      +p{
        アンケートの結果を見るに、Henkin構成による完全性定理の証明については、参加者は雰囲気くらいは知っていると思ってよさそうなので、一旦可算言語の完全性定理を認めて、一般の濃度の言語に関する完全性定理を示すことにしよう。可算言語の完全性定理については、無限組合せ論パートでおるうぇくんが面白い証明をやってくれる予定である。
      }

      +proof?:({一般濃度の言語に関する完全性定理の証明})<
        +p{
          宣言通り、可算言語に対する完全性定理を認める。${\mathcal{L}}を任意の濃度の言語とし、${T}を${\mathcal{L}}-公理系として、${T + \lnot \varphi}が無矛盾であるとして、${M \models T + \lnot \varphi}を満たす${\mathcal{L}}-構造${M}の存在を証明したい。
        }
        +p{
          それには、コンパクト性定理より、${T + \lnot \varphi}の有限部分集合がモデルを持つことが示せればよい。そこで、任意に有限集合${S \Subset T}を固定して、${S + \lnot \varphi}のモデルが取れることを示せればよい。
          だが、${S + \lnot \varphi}は有限集合であるため、この公理系に現れる関数・有限記号は有限個である。そこで、${\mathcal{L}}の語彙をこの有限個に制限した小さな言語${\mathcal{L}'}を考えれば${S + \lnot \varphi}は${\mathcal{L}'}-公理系と見做す。仮定より${S + \lnot \varphi}は無矛盾なので、可算言語に対する完全性定理によりモデルは常に存在する。
        }
      >

      +p{我々の主目的は種々の命題の独立性の証明であった。この文脈では、専ら完全性定理は以下の系の形で使う：}

      +cor?*?:({完全性定理})<
        +p{公理系${T}について次は同値：}
        +enumerate{
          * ${T}は無矛盾
          * ${T}はモデルを持つ
        }
      >

      +p{つまり、ある体系の無矛盾性を示したければそのモデルを構成すればよいし、モデルが構成できないのならその体系は矛盾していると思ってよい、ということである。強制法はモデルの構成法であり、無矛盾性証明の道具としての有用性はこの系に立脚している。}
    >

    +subsection{超積の応用2：超準解析}<
      +p{TODO: 書く}
    >

    +subsection{Löwenheim–Skolemの定理}<
      +p{
        上では超積やコンパクト性定理によって、初等拡大モデルが取れることを見た。しかし、こうした方法で得られるモデルがどのような濃度を持つのかは一般にはよくわからない。というか実は、一般に超冪の濃度が何になり得るのかというのは、巨大基数なども絡んでくる独立命題である。
      }
      +p{
        では、狙った濃度になるように初等部分モデルや初等拡大を取る方法はないのだろうか？
        できる、というのが\emph{\ruby[`レーヴェンハイム`; ` `; `スコーレム`][{Löwenheim};{–};{Skolem}];の定理}である。
        これを述べるために、言語の濃度の概念を定義する：
      }
      +defn<
        +p{言語${\mathcal{L} = \pangle{\bm{R}^{(n_i)}_i, \bm{f}^{(m_j)}_j}_{i \in I, j \in J}}の\emph{濃度}${\pabs{\mathcal{L}}}を${\pabs{\mathcal{L}}\defeq \pabs{I} + \pabs{J} + \aleph_0}と定める。}
      >
      +remark<+p{基数の和は単純に${\max}と一致する。論理式は任意有限長あり得るので、記号の数が有限でも最低${\aleph_0}個は論理式があるということに注意しよう。}>
      +exercise?:(`exc:counting-fml`)<+p{${\pabs{\mathcal{L}}}は${\mathcal{L}}-論理式全体の濃度および${\mathcal{L}}-項全体の濃度と一致することを証明せよ。（\font-style[bold]{ヒント：無限基数${\kappa}について${\kappa^{<\omega} = \kappa}}）}>
      +theorem?*?:({Löwenheim–Skolem（–Tarski）の定理})<
        +p{${\mathcal{M}}を無限${\mathcal{L}}-構造とする。}
        +enumerate{
          * \emph{上方Löwenheim–Skolem}：任意の${\kappa \geq \pabs{\mathcal{M}}}に対し${\pabs{N} = \kappa}なる初等拡大${\mathcal{N} \succ \mathcal{M}}が存在する。
          * \emph{下方Löwenheim–Skolem}：${\pabs{\mathcal{L}} \leq \kappa \leq \pabs{\mathcal{M}}}とし、${S \subseteq \mathcal{M}}を濃度${\kappa}以下の${\mathcal{M}}の部分集合とする。このとき、${S \subseteq \mathcal{N}}かつ${\pabs{\mathcal{N}} = κ}となる${\mathcal{M}}の初等部分構造${\mathcal{N} \subseteq \mathcal{M}}が存在する。
        }
      >
      +p{証明に無限組合せ論で重要な概念を含むので、ここでは下方Löwenheim–Skolemの定理の証明の概略を以下で紹介する。上方の方は演習問題とする。}
      +exercise?*?:({上方Löwenheim–Skolem})<
        +p{上方Löwenheim–Skolemの定理を証明せよ。}
        +pn{\font-style[bold]{ヒント：コンパクト性定理をつかう。${\kappa}個の新しい定数記号${\Seq{c_\xi}{\xi < \kappa}}を導入し、それらが「pairwiseに全て異なる」という公理を足した公理系を考え、最後に下方Löwenheim–Skolemを使えばよい。}}
      >
      +p{下方の基本的な考え方は、存在論理式の「証拠」があれば持ってくるような関数を考えて、それらについて閉じているような部分集合を取ってくるというものである。まず、一般に次の補題が成り立つ：}
      +lemma?:(`lem:closure`)?:({閉包の存在と濃度})<
        +p{
          集合${A}と${A}上の${\lambda}個の有限引数関数の族${\Seq{f_\xi: A^{n_i} \to V}{\xi < \lambda} }について、次で定義される${\bar{f}}による${A}の\emph{閉包}${\Cl_{\bar{f}}(A)}を考える：
          \align?:(AZMathEquation.notag)(${
          | C_0 | \defeq A
          | C_{i + 1} | \defeq \bigcup_{\xi < \lambda} f_k[C_i^{n_k}] = \Set{f_k(\bar{a})}{k < \omega, a_0, \ldots, a_{n_k-1} \in C_i^{n_k}}
          | \Cl_{\bar{f}}(A) | \defeq \bigcup_{i < \omega} C_i
          |});
          このとき、${\pabs{\Cl_{\bar{f}}(A)} \leq \pabs{A} + \lambda + \aleph_0}であり、更に${\Cl_{\bar{f}}(A)}は${A}を含み全ての${\bar{f}}について閉じているような（i.e. ${f_k[\Cl_{\bar{f}}(A)] = \Cl_{\bar{f}}(A)}となるような）最小の集合である。
        }
      >
      +proof<
        +p{
          ${\kappa \defeq \pabs{A}}、${C \defeq \Cl_{\bar{f}}(A)}とおく。${\kappa, \lambda}は無限として${\pabs{C} = \lambda + \kappa}を示せば十分である。
        }
        +p{
          まず濃度を評価する。
          各ステップでは、${\lambda}個の有限引数の関数を適用しているので、${\lambda \cdot \kappa^{<\aleph_0} = \lambda + \kappa}個ずつしか増えない。それを${\aleph_0}回繰り返しているので、結局全体として濃度は${\pabs{C} \leq \aleph_0 \cdot \lambda \cdot \kappa = \lambda + \kappa}となる。よってOK。
        }
        +p{
          ${C}が${\bar{f}}について閉じている事を見る。そこで、${f_\xi: M^n \to V}と${a_0, \ldots, a_{n-1} \in C}を取る。${C}は可算鎖の和なので、ある${N < \omega}があって、${a_i \in C_N}となる。すると、${f_\xi(a_0, \ldots, a_{n-1}) \in C_{N+1} \subseteq C}となる。
        }
        +p{最小性は明らか。}
      >
      +defn?*?:({Skolem関数、Skolem包})<
        +p{${\mathcal{M}}を${\mathcal{L}}-構造とする。}
        +enumerate{
          * 自由変数として${x_0, \ldots, x_{n-1}, y}のみを持つ論理式${\varphi(\bar{x}, y)}を考える。${\mathcal{M}}における${\varphi}の\emph{Skolem関数}（\emph{Skolem function}）${f: \mathcal{M}^n \to \mathcal{M}}とは、以下を満たすものである：
            \eqn-notag(${
              f(a_0, \ldots, a_{n-1}) 
                =
              \cases!(${|
                  b \mathrel{\text!{s.t.}} M \models \varphi(\bar{a}, b) |(\mathrel{\text!{if}} \mathcal{M} \models \exists \varphi(\bar{a}, y))
              | \text!{適当な${\mathcal{M}}の元} | (\text!{otherwise})
              |})
            });
          * 各${\mathcal{L}}-論理式${\varphi}に対し、${\mathcal{M}}におけるSkolem関数${f_{\varphi}}を固定する。部分集合${A \subseteq \mathcal{M}}の${\mathcal{L}}についての${\mathcal{M}}での\emph{Skolem包}（\emph{Skolem hull}）${\Sk^{\mathcal{M}}(A)}を、この${\mathcal{F}= \Set{f_{\varphi}}{\varphi \in \mathcal{L}}}に関する閉包で定める：${\Sk^{\mathcal{M}}(A) \defeq \Cl_{\mathcal{F}}(A)}。
        }
      >
      +lemma?:(`lem:skolem-hull`)<
        +p{${\mathcal{M}}を${\mathcal{L}}-構造とする。}
        +enumerate{
          * ${\Sk^{\mathcal{M}}(A)}は${A}を含む${\mathcal{M}}の部分構造である。
          * ${\Sk^{\mathcal{M}}(A) \prec \mathcal{M}}。
        }
      >
      +proof<
        +p{${N \defeq \Sk^{\mathcal{M}}(A)}とおく。}
        +enumerate{
          * 関係の解釈は自然に入るので、関数について閉じていることが言えればいい。
            ここで、各関数記号${\bm{f}^{(n)}}について、${\mathcal{M} \models \forall \bar{x} \exists y \mhquad \bm{f}(\bar{x}) = y}が成り立つので、特にSkolem関数${f_{\bm{f}(x_0, \ldots, x_{n-1}) = y}}は${f}と全く同じになっている。
            よって\ref(`lem:closure`);より、${f(\bar{a}) \in \Sk^{\mathcal{M}}(A)}となる。よって部分構造である。
          * \ref(`lem:Tarski-Vaught`);を使う。${\bar{a} \in N}と${\mathcal{L}}-論理式${\varphi(\bar{a},y)}を任意に取り、${\mathcal{M} \models \exists y \varphi(\bar{a}, y)}として、${\mathcal{M} \models \varphi(\bar{a}, b)}となる${b \in N}が取れればよい。
            Skolem関数${f_{\varphi}}を考えると${N}は${f_\varphi}について閉じているので、${f_{\varphi}(\bar{a}) \in N}となる。
            また、Skolem関数の定義より${\mathcal{M} \models \varphi(\bar{a}, f_{\varphi}(\bar{a}))}である。よって、${b \defeq f_{\varphi}(\bar{a})}とすればよい。
        }
      >
      +proof?:({Proof of Downward Löwenheim–Skolem})<
        +p{
          \ref(`lem:skolem-hull`);および\ref(`lem:closure`);から、${A \subseteq \Sk^\mathcal{M}(A) \prec \mathcal{M}}であり、言語の濃度と論理式の濃度は一致し（\ref(`exc:counting-fml`);）仮定より${\pabs{L} \leq \pabs{A}}なので、ふたたび補題\ref(`lem:closure`);より
          \eqn-notag(${\pabs{\Sk^\mathcal{M}(A)} \leq \pabs{\mathcal{L}} + \pabs{A} + \aleph_0 = \pabs{A} \leq \kappa});
          となる。${\kappa}に足りなければ、予め${\pabs{A} = \kappa}になるように${\Sk}を取る前に増やしておけばよい。
        }
      >
    >

  >

  +section?:(`chap:incomp`){不完全性定理とTarskiの真理定義不可能性定理}<
    +p{本節の主題は、次のGödelの第二不完全性定理である：}
    +theorem?*?:({Gödelの第二不完全性定理})<
      +p{${T}をペアノ算術${\mathrm{PA}}を含む再帰的な公理系とする。このとき、${T}からは${\mathrm{Con}(T)}を証明できない。}
    >
    +remark<
      +p{よく通俗的理解では不完全性定理は「理性の限界」を示したという解説のされかたをするが、これは現代の数理論理学を研究する者から見ると些か的外れな理解である。そもそも、Hilbertが算術の無矛盾性証明を23の問題の第二問題として挙げたのは、数学が矛盾すると思っていたからではない。
      Gödelの不完全性定理が教えるのは、十分に強い公理系は無矛盾性の強さによって階層を成す、という事である。階層を成すのであれば、それを分類したくなるのが数学者の性である。Gödelの不完全性定理は、「理性の限界」などというネガティヴな事項を示したのではなく、公理系たちの成す豊穣な階層が存在するということを示したポジティヴな定理なのである\raisebox(4pt){\font-style[with-font-size(fun sz -> sz *' 0.5)]{[要出典]}}。
      }
    >
    +p{通常、第二不完全性定理は次の第一不完全性定理を${T}の中で再度定式化することで得られる：}
    +theorem?*?:({Gödelの第二不完全性定理})<
      +p{${T}をペアノ算術${\mathrm{PA}}を含む再帰的な公理系とする。このとき、${T}からは否定も肯定も証明できない独立命題が存在する。}
    >
    +p{これらの定理の偉いところは、メタ理論として十分弱い公理系を採用しても証明できるところである。}

    +p{
      しかし、強制法による集合論的な命題の無矛盾性証明においては${\ZF}の無矛盾性は仮定され、完全性定理から無矛盾性について考える上ではモデルの存在のみを考えればよい。
      特に、第二不完全性定理を証明するのに、第一不完全性定理の再形式化を考える必要はなく、意味論的な議論により簡略に証明することができる。また、十分強い${\ZF}以上の集合論を考えているため、Gödel数化などの技術的な道具を使ったり、対応の原始再帰性のような細かい条件を気にする必要もなくなる。
      我々が目標とするのは、次の定理である：
    }

    +theorem?*?:({不完全性定理、${\ZF}版})<
      +p{${T}が${\ZF}を拡張する公理系とするとき、${T \nproves \Con(T)}である。}
    >
    +p{以下、簡単のため${T = \ZFC}とするが、以下では本質的には選択公理を使っておらず、また同じ議論が${\ZF}を含む理論にも適用できる。}

    
    +p{上は、次の定理の系として得られる：}
    +lemma<+p{
      ${\ZFC \proves \pB{\Con(\ZFC) \to \exists M \models \ZFC \mhquad M \models \lnot\Con(\ZFC)}}
    }>
    +proof?:({Proof of Incompleteness Theorem})<
      +p{
        ${\ZFC}で作業する。${\ZFC \proves \Con(\ZFC)}とする。すると、上の補題より${\ZFC \proves \pB{\exists M \models \ZFC \mhquad M \models \lnot\Con(\ZFC)}}となる。
        そこで、そのようなモデル${M \models \ZFC \land \lnot \Con(\ZFC)}を取る。
        このとき、メタレベルで${\ZFC}からの${\Con(\ZFC)}証明${P}を考えると、${M}は${\ZFC}のモデルであることから、${\code{P}^M \in M}であり、かつ${M \models \code{P}^M \text!{は${\Con(ZFC)}の証明}}となる。
        よって${M \models \Con(\ZFC)}となるが、これは矛盾である。
      }
    >

    +remark<
      +p{
        ここで、集合論のモデルにおける自然数や「有限的」な対象の解釈について注意をしておく。
      }
      +p{
        既に見たように、コンパクト性や超積などを用いることで、超準的な自然数や実数を持つようなモデルを創り出すことができた。同様の事は集合論のモデルに対しても適用できる。
        つまり、集合論の「モデル」があったとすると、このモデルは少なくとも我々の知っていて書き下すことのできるような、\emph{標準的な自然数や有限的な対象は全て持っていて}、メタレベルの有限的な対象をモデル内の対象に対応づけるメタ的な方法がある。
        しかし、こうしたモデルは\emph{超準的な（標準的でない）自然数や有限対象}を持っているということが有り得る。
        ${\mathcal{L}_{\in}}-論理式全体や証明図の全体は可算で、特に自然数との間には自然な全単射があるから、こうした超準モデルの内部には、内側から見ると有限だが、外から見れば無限のように見える「変な論理式」「変な証明図」が存在することになる。
      }
      % +p{
      %   例を挙げよう。${\ZFC}は無矛盾であると仮定し、第二不完全性定理を一旦認める。とくに、${\ZFC \nproves \Con(\ZFC)}である。すると、今度は\ref(`lem:unprovable`);および完全性定理（！）より、${M \models \ZFC + \neg \Con(\ZFC)}を満たすようなモデル${M}が取れる。つまり、${M}は「自分は${\ZFC}のモデルだが、${\ZFC}は矛盾しているよ」と信じ込んでいる（！！！）モデルである。
      % }
      % +p{
      %   すると、この${M}の中には、\emph{${\ZFC}の公理から出発して${\bot}に至る「証明図」が存在}する。しかし、今仮定から${\ZFC}は無矛盾なので、この「証明図」は${M}の中で見ると有限的だが、外の我々から見ると超有限的な対象になっているヘンな証明図であり、対応する有限的な対象が我々の世界にはない超準元である。
      % }
      +p{このように、モデルの取り方によってはその世界には「変な自然数」「変な論理式」「変な証明図」が含まれており、有限概念は一致するとは限らない。
      また、そのモデルでの${\in}-関係は外の${\in}と一致するとは限らないので、標準的な自然数や論理式のコードが集合として外側のものと一致するとも限らないことにも注意しよう。
      こうした事を念頭に置いて以下の議論に臨まれたい。}
    >

    +p{
      以後、（我々の知っている）論理式${\varphi}に対して、その${\ZFC}のモデル内での表現を${\code{\varphi}}と表し、${\varphi}のコードと呼ぶ。いわゆるGödelコード化だと思ってもよいが、${\ZFC}を使っているので、論理式や証明図は列を使って直感的に定式化できる。
      大事なことは、我々の知っている言語・項・論理式・証明図をそのまま${\ZFC}で素直に定義でき、そのことをちゃんと（めちゃ長いから書かないが）具体的な論理式として書き下すことができる、という点である。
    }

    +p{不完全性定理の証明で重要な役割を果すのが、次の補題である：}

    +lemma?*?:({対角化定理または不動点定理})<
      +p{任意の${\Phi}-論理式${\Phi}に対して、閉論理式${\delta}で以下が成り立つものが存在する：}
      +eqn-notag(${
        \ZFC \proves \delta \liff \Phi(\code{\delta})
      });
    >
    +proof<
      +p{
        ここで、関数${s: \HF \times \HF \to \HF}を次のように定める：
        \eqn-notag(${
          s(a, b) \defeq 
            \cases!(${
              |\code{\psi(b)} 
              | (\text!{if\hquad;} a = \code{\psi(x)}\text!{\hquad; for some unary ${\psi(x)}})
              |\emptyset|(\text!{otherwise)}
            |})
        });
        つまり、${a}が自由変数を一つだけ持つ論理式のとき、その変数に${b}を代入するような関数が${s}である。
      }
      +p{
        そこで、新たに一変数の論理式${\gamma(x) \deffml \Phi(s(x, x))}を考える。${s}は言語に関数記号が入っているわけではないが、${\ZF}で定義できる関数であり、特に${z = s(x, y)}に相当する論理式が書けるので、定義による拡張から以下のように同値な書き換えができることに注意しよう：
        \eqn-notag(${
          \gamma(x) \deffml \forall z \mhquad \pB{z = s(x, x) \to \Phi(z)}
        });
        ここで、更に${d \defeq \code{\gamma(x)}}と置くと、${s}の定義から${s(d, d) = \code{\gamma(d)}}となる。
        これらの論理式は全て書き下せるので${\ZF}の定理であり、${\ZFC \proves s(d, d) = \code{\gamma(d)}}である。
        よって、これを${\Phi}に代入すれば（等号公理）：
        \eqn-notag(${
          \ZFC \proves \Phi(s(d, d)) \liff \Phi(\code{\gamma(d)})
        });
        を得る。いま、${\gamma(x) \equiv \Phi(s(x, x))}としていたので、${\delta \deffml \gamma(d)}とおけば：
        \eqn-notag(${
          \ZFC \proves \delta \liff \Phi(\delta)
        });
        となり、これが求める${\delta}である。
      }
    >

    +remark<+p{${\ZFC}は有限公理化不能であり、特に置換公理は無限個の論理式からなる公理スキームである。よって、考えるモデルによって${\ZFC}の公理全体の集合というものは変わってくる。そこで、以下の表記法を採用する：}>
    +notation<
      +p{
        以下、${\ZFC}と書いたらメタレベルのホンモノの${\ZFC}の公理系をあらわすとし、${M}を集合論のモデルとするとき${(\ZFC)^M}はモデル${M}内での${\ZFC}の公理系とする。
        また、コード${\code{-}}をどこで考えているかを明示する際にも${\code{-}^M}などと書く。
      }
    >

    +p{以下、${V}で作業をする。}
  >

  +section{参考文献}<
    +p{
      第\ref(`chap:syntax`);節で触れた証明論的な話題については、\cite[`古森・小野:2010`; `戸次:2012`];を参考にした。第\ref(`chap:semantics`);、\ref(`chap:models`);節で紹介した意味論的な話題は\cite[`新井:2011`; `江田:2010`; `愛知非古典論理`];に基づいている。また、コンパクト性定理からの任意濃度の理論に対する完全性定理の証明についてはMathoverflowのKukiełaの回答\cite[`Kukieła:2010`];を直接的に参考にした。
      第\ref(`chap:incomp`);節の不完全性定理や真理定義不可能性定理については、\cite[`デデキント`; `林八杉:2006`; `渕野:2016`; `菊池:2014`; `照井:2015`; `フランセーン:2011`];が詳しい。特に、今回紹介したWoodinによる第二不完全性定理の意味論的な証明は渕野\cite[`渕野:2016`; `デデキント`];を参考にしている。
    } 
    +makebibliography 
          ?:(|sort-references=true; 
              citestyle=CiteAsNumber;
              name-shrink=true;
            |)
          (bib-theme)(bibs);
  >
>